% Created 2025-11-22 Sat 08:26
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\setlength{\parindent}{0pt}
\usepackage{hyperref}
\usepackage{ccicons}
\usepackage[
type={CC},
modifier={by-sa},
version={4.0},
]{doclicense}
\author{Deepak Venkatesh}
\date{\today}
\title{The Schemer Simplified}
\hypersetup{
 pdfauthor={Deepak Venkatesh},
 pdftitle={The Schemer Simplified},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 29.4 (Org mode 9.6.15)}, 
 pdflang={English}}
\begin{document}

\thispagestyle{empty}
\begin{center}
\vspace*{0.3\textheight}
\large {\emph{``Programs must be written for people to read, \newline and only incidentally for machines to execute.''}}
\footnote{\href{https://web.mit.edu/6.001/6.037/sicp.pdf} {Structure \& Interpretation of Computer Programs by Abelson, Sussman \& Sussman}}\\[1em]
\bigskip
\vfill
\end{center}
\clearpage




\clearpage\maketitle

\begin{abstract}
This is fundamentally a study guide from my personal notes initially created to deepen my understanding of Lisp and programming in general.
`The Little Schemer' (4th edition) by Daniel Friedman and Matthias Felleisen is a remarkable book
that teaches programming concepts in a unique and playful way. It builds from first principles using only
a small set of primitives, showing how powerful ideas — such as recursion, functional programming, lambda
functions, closures, higher order functions, and interpreters can be expressed using just those few building
blocks. I am sharing this since other beginners could benefit from these pages. As Richard Feynman had said `If you want to master
something, teach it.' In the future I hope to append a similar guide for the sequel `The Seasoned Schemer' to this book.

\bigskip

While the book uses Scheme, I initially worked it out using Common Lisp and had adapted the examples accordingly. Now
I am working through it using Racket, a modern descendent of Scheme. Despite its lighthearted tone, the book is far
from an easy read. It demands close attention and careful thought. My advice to anyone who wants to learn Lisp is to
first work through Professor David Touretzky's book titled `Common Lisp A Gentle Introduction to Symbolic Computing'
(2nd ed.). It's a great book for introduction to programming not just Lisp. Throughout this guide I have given additional clarification
and background about computer science concepts which are not present in the `The Little Schemer'.

\bigskip

I am really thankful to Alonzo Church, John McCarthy, Daniel Friedman, Matthias Felleisen, Gerald Sussman, Guy Steele, and the PLT research group for
giving to us this wonderful language and book. I stumbled upon Lisp very late in life via a blog by Steve Losh and ventured into the grand language of Common Lisp via David Touretzky, Peter Seibel,
Paul Graham, and Peter Norvig. As a non programmer whose daily job has never involved writing a line of production code I could not have spent hours on end without the support of my family.
My daughter knows the names of half a dozen programming languages by now and has tried her hand at some concepts. She prefers Python though.

\bigskip

Who is this book and guide for? At the end of The Seasoned Schemer the authors say `You have reached the end of your introduction to computation.' But I feel differently about it.
This book is not an introduction to programming and neither this guide is. Readers should either have some understanding of Lisp to work through this book or experience with programming. If a
reader does take this book on without any knowledge of programming and a bit of introduction to Lisp then they will find it difficult but not impossible to work through especially the chapters 8, 9, and 10 in the book.
Chapter 9 is the most difficult followed by chapter 8 and then chapter 10. Rest of the chapters are fairly easy to moderate. I would say chapter 9 is the most difficult in both the books. I will be adding more details and
illustrations at a future date to make this even more readable.

\bigskip

This guide is not intended for any commercial purpose and all rights of `The Little Schemer' and `The Seasoned Schemer' are with the respective authors and publishers. This is only a deep study
of these two wonderful books.

\bigskip

All mistakes in this guide, whether typographical or conceptual, are entirely my own. Any misinterpretations are as
well. I am still learning Lisp and programming. With every subsequent reading of this book I learn something new and peel another layer of Lisp.


\vspace{1em}

\emph{Hardware and Software used for this study}
\begin{itemize}
\item Language: Racket (a Scheme)
\item Editor: Dr Racket
\item emacs for Org notes
\item chatgpt for assistance on Git and Org mode
\item Macbook Pro 2019 2.6 Ghz I7 Intel chip with 16 GB RAM
\end{itemize}
\end{abstract}

\bigskip
\bigskip
\begin{flushright}
'(deepak venkatesh)\\[0pt]
'(redmond wa usa)
\end{flushright}



\newpage
\vfill
\doclicenseThis

\clearpage
\setcounter{tocdepth}{4}
\tableofcontents
\clearpage

\section{Foreword}
\label{sec:orge085cf0}

By Gerald Sussman of MIT, co-author of the book SICP (the wizard book).

\bigskip

Key Takeaway:
\emph{In order to be creative one must first gain control of the medium.}

\vspace{1em}

\begin{itemize}
\item Core skills are the first set of things required to master any pursuit.
\item Deep understanding is required to visualize beforehand the program which will be written.
\item Lisp provides freedom and flexibility (this is something which will only come in due course of time, as we keep
learning more about programming).
\item Lisp was initially conceived as a theoretical vehicle for recursion and symbolic algebra (this is the algebra we
have been taught at school such as \((a + b)^2 = a^2 + b^2 + 2ab\)).
\item In Lisp procedures are first class. Procedures are essentially a `variant' of functions. A mathematical function
maps a given input to an output (domain - range/co-domain) but a procedure is a process to arrive at the result via
computation.
\item First Class basically means that the procedure itself can be passed around as arguments to other procedures.
Procedures can be return values. They can also be stored in data structures. A similar corollary (though not exact)
are composite functions which are usually taught in pre-calculus.
\item Lisp programs can manipulate representations of Lisp programs - this likely refers to macros and how in Lisp, code
can be treated as data.
\end{itemize}

\bigskip

\clearpage
\section{Preface}
\label{sec:org64846b7}

Key Takeaway:
\emph{The goal of the book is to teach the reader to think recursively.}

\bigskip

\begin{itemize}
\item Programs take data, apply a process on that data, and then produce some data.
\item Recursion is the act of defining an object or solving a problem in terms of itself.
\item The authors believe that writing programs recursively in Lisp is essentially pattern recongnition. Well I think
it's true for any programming language or any programming paradigm. It is the same in other pursuits too such as mathematics or physics.
\item For recursive programming and studying, this book we will need only a few primitives/functions, namely:
\begin{itemize}
\item \texttt{car}
\item \texttt{cdr}
\item \texttt{cons}
\item \texttt{atom?}
\item \texttt{eq?}
\item \texttt{null?}
\item \texttt{add1}, \texttt{sub1}
\item \texttt{and}, \texttt{or}
\item \texttt{else}
\item \texttt{lambda}
\item \texttt{cond}
\item \texttt{define}
\end{itemize}
\item The definitions of the above primitives I am not outlining here and will come to it as we work through the book.
\item Authors advise to read this book slowly. Very slowly and delibrately. Re-read it multiple times. Every concept
should be clear before going onto the next page. It is better to keep going back and working through a chapter again than to
continue forward without a 100\% clarity.
\item In the preface we hit the first difference between Scheme and Common Lisp. \texttt{()} in Scheme is actually different
from that in Common Lisp. Scheme considers \texttt{()} as \emph{only} a list and \emph{not} an atom. While in Common Lisp \texttt{()} is
considered both an atom and a list. \texttt{ATOM} is defined as per the Lisp Hyperspec as well as Common Lisp The
Language (2nd ed.) by Guy Steele as `The predicate \texttt{ATOM} is true if its argument is not a \texttt{CONS}, and otherwise
is false. In SBCL, a Common Lisp implementation \texttt{ATOM} will give \texttt{T}.

\begin{verbatim}
(atom '())
» T

\end{verbatim}

We define our own predicate \texttt{atom?} in Scheme. 

\begin{verbatim}
(define atom?
  (lambda (x)
    (and (not (pair? x)) (not (null? x)))))

\end{verbatim}

Some tests for checking \texttt{atom?} in Scheme below:

\begin{verbatim}
> (atom? 'a)
#t
> (atom? (quote ()))
#f
> (atom? '(a b c))
#f
> (atom? 42)
#t

\end{verbatim}
\end{itemize}


\textbf{Core Terms/Concepts Learnt}
\begin{itemize}
\item In Scheme \texttt{()} is only a list and not an atom.
\end{itemize}


\newpage
\section{The Five Rules}
\label{sec:orgd79b28b}

\begin{enumerate}
\item The Law of \texttt{car} : The primitive \texttt{car} is defined only for non-empty lists.

\item The Law of \texttt{cdr}: The primitive \texttt{cdr} is defined only for non-empty lists. The \texttt{cdr} of any non-empty list is always another list.

\item The Law of \texttt{cons}: The primitive \texttt{cons} takes two arguments. The second argument to \texttt{cons} must be a list. The result is a list.

\item The Law of \texttt{null?}: The primitive \texttt{null?} is defined only for lists.

\item The Law of \texttt{eq?}: The primitive \texttt{eq?} in takes two arguments. Each must be a non numeric atom.
\end{enumerate}


\newpage

\section{The Ten Commandments}
\label{sec:org88bd4e6}

The First Commandment
\begin{itemize}
\item When recurring on a list of atoms, \texttt{lat}, ask two questions about it: \texttt{(null? lat)} and \texttt{else}. When recurring on a number, \texttt{n}, ask two
questions about it: \texttt{(zero? n)} and \texttt{else}. When recurring on a list of S-expressions, \texttt{l} ask three questions about it: \texttt{(null? l)},
\texttt{(atom? (car l))}, and \texttt{else}.
\end{itemize}

The Second Commandment
\begin{itemize}
\item Use \texttt{cons} to build lists.
\end{itemize}

The Third Commandment
\begin{itemize}
\item When building a list, describe the first typical element, and then \texttt{cons} it onto the natural recursion.
\end{itemize}

The Fourth Commandment
\begin{itemize}
\item Always change at least one argument while recurring. When recurring on a list of atoms, \texttt{lat}, use \texttt{(cdr lat)}. When recurring on a number, \texttt{n}, use \texttt{(sub1 n)}.
And when recurring on a list of S-expressions, \texttt{l}, use \texttt{(car l)} and \texttt{(cdr l)} if neither \texttt{(null? l)} nor \texttt{(atom? (car l))} are true. It must be changed to be closer to
termination. The changing argument must be tested in the termination condition: When using \texttt{cdr}, test termination with \texttt{null?} and when using \texttt{sub1}, test termination with \texttt{zero?}.
\end{itemize}

The Fifth Commandment
\begin{itemize}
\item When building a value with \texttt{+}, always use 0 for the value of the terminating line, for adding \texttt{0} does not change the value of an addition.
When building a value with \texttt{x}, always use 1 for the value of the terminating line, for adding \texttt{1} does not change the value of a multiplication.
When building a value with \texttt{cons}, always consider \texttt{()} for the value of the terminating line.
\end{itemize}

The Sixth Commandment
\begin{itemize}
\item Simplify only after the function is correct.
\end{itemize}

The Seventh Commandment
\begin{itemize}
\item Recur on the \emph{subparts} that are of the same nature
\begin{itemize}
\item On the sublists of a list.
\item On the sub-expression of an arithmetic expression.
\end{itemize}
\end{itemize}

The Eight Commandment
\begin{itemize}
\item Use help functions to abstract from representations.
\end{itemize}

The Ninth Commandment
\begin{itemize}
\item Abstract common patterns with a new function.
\end{itemize}

The Tenth Commandment
\begin{itemize}
\item Build functions to collect more than one value at a time
\end{itemize}

\newpage
\section{Toys}
\label{sec:org51e09fe}

This chapter introduces the primitives of Scheme. These are the basic building blocks.

\bigskip

\subsection{The Law of \texttt{car}}
\label{sec:org814ba1c}
Key Takeaway:
\emph{The primitive \texttt{car} is defined only for non-empty lists. The \texttt{car} is the first atom (element) of that list.}

\vspace{1em}

\begin{itemize}
\item An atom is indivisible - number, strings.
\item Anything enclosed in parenthesis/brackets \texttt{()} is a list.
\item We can have nested lists which are also called improper lists and non-nested lists which are proper lists.
\item An S-expression which stands for Symbolic Expression is any Lisp object that can be read and evaluated by the
Lisp reader.
\item Q. How many S-expressions are in the list \texttt{(how are you doing so far)} and what are they? The book answers 6 and
those are the elements in the lists, basically the 6 atoms inside the list.
\item A question asks how many S-expressions are in the list \texttt{(((how) are) ((you) (doing so)) far)} and gives the
answer as 3. It refers to the 3 lists inside the outermost list.
\item The difference of \texttt{()} again comes up since it is both a list and an atom in Common Lisp unlike Scheme. The \texttt{car}
of \texttt{()} will be \texttt{NIL} in Common Lisp unlike Scheme. In Common Lisp as per the standards and empty list's \texttt{car} and
\texttt{cdr} are both \texttt{NIL} (shown below).
\begin{verbatim}
(car ())
» NIL

\end{verbatim}
\item \texttt{car} is the first atom/element of a list. If we try to find the \texttt{car} of a string of character or numbers we will
get an error like below.
\begin{verbatim}
  > (car 'a)
. . car: contract violation
  expected: pair?
  given: 'a
> (car 42)
. . car: contract violation
  expected: pair?
  given: 42

\end{verbatim}
\end{itemize}

\subsection{The Law of \texttt{cdr}}
\label{sec:orgbc2d30a}
Key Takeaway:
\emph{The primitive \texttt{cdr} is defined only for non-empty lists. The \texttt{cdr} of any non-empty list is always another list.}

\vspace{1em}

\begin{itemize}
\item The book says \texttt{car} of \emph{l} is same as \texttt{(car l)}. Similarly for \texttt{cdr}.
\item \texttt{cdr} of a single atom/element list is \texttt{()}.
\item In Prof Tourtezky's book there is a tool called SDRAW. It allows us to do draw \texttt{cons} cell structures with the \texttt{car} \&
\texttt{cdr} pointers. I have uploaded the code for this tool on Github \href{https://github.com/PeepalCapital/sdraw}{here}. For \texttt{(car a)} and \texttt{(cdr a)} where \texttt{a} is
\texttt{samosa} will be represented as below (doesn't render well in markdown file on github):

\texttt{[*|*]-{}-{}-> NIL} \(\newline\)
\texttt{|} \(\newline\)
\texttt{|} \(\newline\)
\texttt{V} \(\newline\)
\texttt{SAMOSA}

\item \texttt{cdr} of an empty list will be \texttt{()} as per Common Lisp standards but in Scheme it is an error.
\end{itemize}


\subsection{The Law of \texttt{cons}}
\label{sec:org00f9011}
Key Takeaway:
\emph{The primitive \texttt{cons} takes two arguments. The second argument to \texttt{cons} must be a list. The result is a list.}

\vspace{1em}

\begin{itemize}
\item \texttt{cons} actually creates a \texttt{cons} cell. The \texttt{car} of which is the first input to \texttt{cons} and the \texttt{cdr} is pointed to
the second input. The return value of the \texttt{cons} is a pointer to it. Refer Prof Touretzky's Chapter 2, clearly explained.
\item Q. What is \texttt{(cons s l)} where \texttt{s} is \texttt{((a b c))} and \texttt{l} is \texttt{b}? This brings in the topic of Dotted Lists. In a
proper list the chain of \texttt{cons} cells ends with \texttt{()} as the atom, meaning the last cell points to a \texttt{NIL} but in a
dotted list the last atom points to a non \texttt{NIL} atom. In the above case we will get the following:
\begin{verbatim}
> (cons 'a '(b c))
'(a b c)
> (cons 'a 'b)
'(a . b)

\end{verbatim}
\end{itemize}


\subsection{The Law of \texttt{null?}}
\label{sec:org42d74ea}
Key Takeaway:
\emph{The primitive \texttt{null?} is defined only for lists.}

\vspace{1em}

\begin{itemize}
\item Q. Is it true that the list \texttt{l} is the null list where \texttt{l} is \texttt{()}? Yes, because it is  composed of
zero S-expressions.
\item Another difference in Common Lisp and Scheme is how they refer to False. In scheme it is explicitly \texttt{\#t} or \texttt{\#f} but
in Common Lisp it is \texttt{T} for True or else it is \texttt{NIL} which means False.
\item \texttt{null?} of an atom should throw an error for a string or a number but actually it gives \texttt{\#f} since in Scheme \texttt{null?}
for \texttt{()} is \texttt{\#t} and for everything else it is \texttt{\#f}. See code below.
\begin{verbatim}
  > (null? 'a)
#f
> (null? (quote ()))
#t

\end{verbatim}
\end{itemize}

\subsection{The Law of \texttt{eq?}}
\label{sec:org98b649e}
Key Takeaway:
\emph{The primitive \texttt{eq?} in takes two arguments and compares them. Each must be a non numeric atom.}

\vspace{1em}

\begin{itemize}
\item In \texttt{eq?} the address of the Lisp object is compared. For instance if we create two cons cells with same elements
\texttt{eq?} will give \texttt{\#f}
\begin{verbatim}
> (eq? (cons 'a 'b) (cons 'a 'b))
#f

\end{verbatim}
\end{itemize}

\textbf{Core Terms/Concepts Learnt}
\begin{itemize}
\item \texttt{car}, \texttt{cdr}, \texttt{cons}, \texttt{eq?}, \texttt{null?}, \texttt{quote}, \texttt{\#t}, \texttt{\#f}
\item Atoms, S-Expressions, Lists, Dotted Lists
\end{itemize}


\newpage
\section{Do It, Do It Again, and Again, and Again \ldots{}}
\label{sec:org692baac}

This chapter explains recursion. The best introductory material for recursion in my opinion is Chapter 8 in Prof Touretzky's book.

\vspace{1em}

Key Takeaway:
\emph{The First Commandment (preliminary): Always ask \texttt{null?} as the first question in expressing a function}

\vspace{1em}

\subsection{Basics of Recursion}
\label{sec:org77a9085}

\begin{itemize}
\item After reading Prof Touretzky's chapter on recursion this chapter will feel very easy. Also the first commandment is not
really true always. Sometimes in recursion the first question is not necessarily \texttt{null?}. Later in the book the
authors do add in this nuance.
\item The chapter introduces a function named \texttt{lat?}. It stands for a list of atoms. This means every element of the
list is an atom. It can be written as below.
\begin{verbatim}
(define lat?
  (lambda (l)
    (cond
      ((null? l) #t)
      ((atom? (car l)) (lat? (cdr l)))
      (else #f))))

\end{verbatim}
\end{itemize}

\subsubsection{The important \texttt{cond}}
\label{sec:org80bf508}

\begin{itemize}
\item It is important to understand how \texttt{cond} functions. Well \texttt{cond} is actually a macro. This macro has a series of
tests and results. The macro goes from top to bottom. The cases are processed from left to right under each test.
Technically we can have more than one result per test for evaluation. As a Lisp `trick' the last test is
usually an \texttt{else} which evaluates to \texttt{\#t} always and hence the last result is returned. \texttt{cond} is a very nice way to
implement \texttt{If..then..Else}. I have never seen such seamless conditional in any language yet.
\item \texttt{lat?} basically is a \texttt{cond} which keeps checking through all the elements of a list to test for \texttt{atom?} till the
list ends. It checks \texttt{car} one by one for each subsequent \texttt{cdr} for \texttt{atom?}.
\item I would study Chapter 8 of Touretzky for getting the intuition on recursion right. The author has done a great job.
\end{itemize}

\subsubsection{Trace tool in Dr Racket}
\label{sec:org3163f57}

\begin{itemize}
\item Dr Racket comes with an inbuilt tool called \texttt{trace} in the library package called \textasciitilde{}(racket/trace) which lets us see
the actual function calls. So lets trace all the recursive examples in this chapter.
\begin{verbatim}
> (lat? '(Jack Sprat could eat no chicken fat))
>(lat? '(Jack Sprat could eat no chicken fat))
>(lat? '(Sprat could eat no chicken fat))
>(lat? '(could eat no chicken fat))
>(lat? '(eat no chicken fat))
>(lat? '(no chicken fat))
>(lat? '(chicken fat))
>(lat? '(fat))
>(lat? '())
<#t
#t

\end{verbatim}

\item Another example which has a nested list.
\begin{verbatim}
> (lat? '(Jack (Sprat could) eat no chicken fat))
>(lat? '(Jack (Sprat could) eat no chicken fat))
>(lat? '((Sprat could) eat no chicken fat))
<#f
#f

\end{verbatim}
\item Few more examples from the chapter using \texttt{trace}
\begin{verbatim}
> (lat? '(bacon and eggs))
>(lat? '(bacon and eggs))
>(lat? '(and eggs))
>(lat? '(eggs))
>(lat? '())
<#t
#t

\end{verbatim}

\begin{verbatim}
> (lat? '(bacon (and eggs)))
>(lat? '(bacon (and eggs)))
>(lat? '((and eggs)))
<#f
#f

\end{verbatim}
\item \texttt{or} is introduced as a logical operator. \texttt{or} asks two questions, one at a time. If the first one is true it stops
answers true. Otherwise it asks the second question and answers with whatever the second question answers.
\item \texttt{member?} is a function which returns a \texttt{\#t} if the input is one of the elements in a list else \texttt{\#f}. The book
defines this function using \texttt{or} whereas it is actually not necessary.
\begin{verbatim}
    (define member?
      (lambda (a lat)
        (cond
          ((null? lat) #f)
          (else (or (eq? (car lat) a)
                     (member? a (cdr lat)))))))

(define my-member?
  (lambda (a lat)
    (cond
      ((null? lat) #f)
      ((eq? (car lat) a) #t)
      (else (member? a (cdr lat))))))

\end{verbatim}
\item The application of \texttt{member?} to find out whether \emph{meat} is in the list \emph{(mashed potatoes and meat gravy)} would
generate this recursive call.
\begin{verbatim}
> (member? 'meat '(mashed potatoes and meat gravy))
>(member? 'meat '(mashed potatoes and meat gravy))
>(member? 'meat '(potatoes and meat gravy))
>(member? 'meat '(and meat gravy))
>(member? 'meat '(meat gravy))
<#t
#t

\end{verbatim}
\item Another example.
\begin{verbatim}
> (member? 'liver '(bagels and lox))
>(member? 'liver '(bagels and lox))
>(member? 'liver '(and lox))
>(member? 'liver '(lox))
>(member? 'liver '())
<#f
#f

\end{verbatim}
\end{itemize}

\textbf{Core Terms/Concepts Learnt}
\begin{itemize}
\item \texttt{or}
\item Basic template of recursion. Chapter 8 of Prof Touretzky is great for a deeper dive into ways to construct recursion. Also
tail optimized recursion is to be studied from the book `Sketchy Scheme' by Nils M Holm.
\end{itemize}

\newpage

\section{Cons the Magnificent}
\label{sec:orgd223d1e}

This chapter explains the methods to build lists using \texttt{cons} recursively.

\vspace{1em}

Key Takeaway: \emph{The Second Commandment: Use \texttt{cons} to build lists}

\bigskip

\emph{The Third Commandment: When building a list, describe the first typical element, and then \texttt{cons} it onto the natural recursion}

\bigskip

\emph{The Fourth Commandement: Always change at lest one argument while recurring. It must be changed to be closer to termination.
The changing argument must be tested in the termination condition: when using \texttt{cdr}, test termination with \texttt{null?}.}

\vspace{1em}

\subsection{List Surgery}
\label{sec:org263a92c}

\subsubsection{Removing elements}
\label{sec:orgbd4b659}

\begin{itemize}
\item In last chapter we made a \texttt{member?} function and in this chapter we will be making a function which will \emph{remove}
a member.
\item The first attempt to build the \texttt{rember} function fails since it removes all the initial elements before finding the
one it wants to remove. The authors have nicely demonstrated why \texttt{cons} is required to define this function.
\item The way to write \texttt{rember} is as below. Also note as per Scheme semantics there is no \texttt{?} at the end
of \texttt{rember} because it is actually not a predicate.
\begin{verbatim}
(define rember
  (lambda (a lat)
    (cond
      ((null? lat) (quote ()))
      ((eq? (car lat) a) (cdr lat))
      (else (cons (car lat)
                  (rember a (cdr lat)))))))

\end{verbatim}
\item There is a way to contrast the incorrect \texttt{rember} with the correct \texttt{cons} \texttt{rember} by looking at the recursive
trace calls. The incorrect \texttt{rember-wrong} is below with its trace and return.
\begin{verbatim}
(define rember-wrong
  (lambda (a lat)
    (cond
      ((null? lat) #f)
      ((eq? (car lat) a) #t)
      (else (rember-wrong a (cdr lat))))))

> (rember-wrong 'and '(bacon lettuce and tomato))
>(rember-wrong 'and '(bacon lettuce and tomato))
>(rember-wrong 'and '(lettuce and tomato))
>(rember-wrong 'and '(and tomato))
<'(tomato)
'(tomato)

\end{verbatim}
Whereas the correct trace and output is as below:
\begin{verbatim}
> (rember 'and '(bacon lettuce and tomato))
>(rember 'and '(bacon lettuce and tomato))
> (rember 'and '(lettuce and tomato))
> >(rember 'and '(and tomato))
< <'(tomato)
< '(lettuce tomato)
<'(bacon lettuce tomato)
'(bacon lettuce tomato)

\end{verbatim}
Another example.
\begin{verbatim}
> (rember 'sauce '(soy sauce and tomato sauce))
>(rember 'sauce '(soy sauce and tomato sauce))
> (rember 'sauce '(sauce and tomato sauce))
< '(and tomato sauce)
<'(soy and tomato sauce)
'(soy and tomato sauce)

\end{verbatim}
\end{itemize}

\subsubsection{Finding elements}
\label{sec:org2bf279a}

\begin{itemize}
\item Next function is \texttt{firsts} to build a list of the first S-expressions in nested lists. The code and trace is:
\begin{verbatim}
    (define firsts
      (lambda (l)
        (cond
          ((null? l) (quote ()))
          (else (cons (car (car l))
                      (firsts (cdr l)))))))

>(firsts
  '((apple peach pumpkin)
    (plum pear cherry)
    (grape raisin pea)
    (bean carrot eggplant)))
> (firsts '((plum pear cherry) (grape raisin pea) (bean carrot eggplant)))
> >(firsts '((grape raisin pea) (bean carrot eggplant)))
> > (firsts '((bean carrot eggplant)))
> > >(firsts '())
< < <'()
< < '(bean)
< <'(grape bean)
< '(plum grape bean)
<'(apple plum grape bean)
'(apple plum grape bean)

\end{verbatim}
\item The book refers to \texttt{seconds} but doesn't provide code for it. But I will try it out anyways.
\begin{verbatim}
    (define seconds
      (lambda (l)
        (cond ((null? l) (quote ()))
              (else (cons (car (cdr (car l)))
                          (seconds (cdr l)))))))

>(seconds '((a b) (c d) (e f)))
> (seconds '((c d) (e f)))
> >(seconds '((e f)))
> > (seconds '())
< < '()
< <'(f)
< '(d f)
<'(b d f)
'(b d f)

\end{verbatim}
\item In the recursion technique of \texttt{cons}-ing cells the last \texttt{cons} cells' \texttt{cdr} pointer will point to a \texttt{nil} or an
empty list \texttt{()}. Therefore, the usual terminal or base condition is to check for \texttt{null?} then \texttt{cons} a \texttt{()}.
\item Although the book alludes to the fact that the \texttt{cons}-ing can be in any direction the trace in Dr Racket actually
shows the  \texttt{cons}-ing with a \texttt{<} or a \texttt{>}. So a \texttt{()} gets \texttt{cons}-ed with the last recurring item and goes back to the
first item. In the above example \texttt{()} is \texttt{cons}-ed to \texttt{f} to make a list \texttt{(f)}. This \texttt{(f)} is then \texttt{cons}-ed to \texttt{d}
to make the list \texttt{(d f)}. This \texttt{(d f)} is then \texttt{cons}-ed to \texttt{b} to finally get \texttt{(b d f)}.
\end{itemize}

\subsubsection{Inserting and substituting elements}
\label{sec:org45b1043}

\begin{itemize}
\item Without looking into the questions was able to build these \texttt{cons}-es for \texttt{insertR}, \texttt{insertL}, and \texttt{subst}.
\begin{verbatim}
(define insertR
  (lambda (new old lat)
    (cond ((null? lat) (quote ()))
          ((eq? old (car lat)) (cons (car lat) (cons new (cdr lat))))
          (else (cons (car lat) (insertR new old (cdr lat)))))))

(define insertL
  (lambda (new old lat)
    (cond ((null? lat) (quote ()))
          ((eq? old (car lat)) (cons new (cons (car lat) (cdr lat))))
          (else (cons (car lat) (insertL new old (cdr lat)))))))

(define subst
  (lambda (new old lat)
    (cond ((null? lat) (quote ()))
          ((eq? old (car lat)) (cons new (cdr lat)))
          (else (cons (car lat) (subst new old (cdr lat)))))))

\end{verbatim}
\item \texttt{subst2} is another function defined in the book, it substitutes either the first occurrence of one thing or another.
\begin{verbatim}
(define subst2
  (lambda (new o1 o2 lat)
    (cond ((null? lat) (quote ()))
          ((or (eq? (car lat) o1) (eq? (car lat) o2)) (cons new (cdr lat)))
          (else (cons (car lat) (subst2 new o1 o2 (cdr lat)))))))

\end{verbatim}
\item \texttt{subst2} involves an \texttt{or} but a better example could be used such as below. Since trace will give a better view.
\begin{verbatim}
    (define subst2
      (lambda (new o1 o2 lat)
        (cond ((null? lat) (quote ()))
              ((or (eq? (car lat) o1) (eq? (car lat) o2)) (cons new (cdr lat)))
              (else (cons (car lat) (subst2 new o1 o2 (cdr lat)))))))

> (subst2 'vanilla 'chocolate 'banana
          '(caramel raspberry ice cream with
                    chocolate topping with some bananas))
>(subst2
  'vanilla
  'chocolate
  'banana
  '(caramel raspberry ice cream with chocolate topping with some bananas))
> (subst2
   'vanilla
   'chocolate
   'banana
   '(raspberry ice cream with chocolate topping with some bananas))
> >(subst2
    'vanilla
    'chocolate
    'banana
    '(ice cream with chocolate topping with some bananas))
> > (subst2
     'vanilla
     'chocolate
     'banana
     '(cream with chocolate topping with some bananas))
> > >(subst2
      'vanilla
      'chocolate
      'banana
      '(with chocolate topping with some bananas))
> > > (subst2
       'vanilla
       'chocolate
       'banana
       '(chocolate topping with some bananas))
< < < '(vanilla topping with some bananas)
< < <'(with vanilla topping with some bananas)
< < '(cream with vanilla topping with some bananas)
< <'(ice cream with vanilla topping with some bananas)
< '(raspberry ice cream with vanilla topping with some bananas)
<'(caramel raspberry ice cream with vanilla topping with some bananas)
'(caramel raspberry ice cream with vanilla topping with some bananas)

\end{verbatim}
\item \texttt{multirember} is below. I am unsure why two \texttt{else} is used by the author. Probably I will learn it down the line. But the
\texttt{trace} captures the series of recursive steps beautifully. Note the \texttt{>} and \texttt{<} they capture the stack trace nicely.
\begin{verbatim}
    (define multirember
      (lambda (a lat)
        (cond ((null? lat) (quote ()))
              ((eq? (car lat) a) (multirember a (cdr lat)))
              (else (cons (car lat) (multirember a (cdr lat)))))))

> (multirember 'cup '(coffee cup tea cup and hick cup))
>(multirember 'cup '(coffee cup tea cup and hick cup))
> (multirember 'cup '(cup tea cup and hick cup))
> (multirember 'cup '(tea cup and hick cup))
> >(multirember 'cup '(cup and hick cup))
> >(multirember 'cup '(and hick cup))
> > (multirember 'cup '(hick cup))
> > >(multirember 'cup '(cup))
> > >(multirember 'cup '())
< < <'()
< < '(hick)
< <'(and hick)
< '(tea and hick)
<'(coffee tea and hick)
'(coffee tea and hick)

\end{verbatim}
\end{itemize}

\subsubsection{Multiple surgeries on lists}
\label{sec:org273c0ea}

\begin{itemize}
\item Function definition for other `multi' variants below: \texttt{multiinsertR}, \texttt{multiinsertL}, and \texttt{multisubst}.
\begin{verbatim}
    (define multiinsertR
      (lambda (new old lat)
        (cond ((null? lat) (quote ()))
              ((eq? old (car lat))
               (cons (car lat)(cons new (multiinsertR new old (cdr lat)))))
              (else (cons (car lat) (multiinsertR new old (cdr lat)))))))

> (multiinsertR 'bag 'cup '(coffee cup tea cup and hick cup))
>(multiinsertR 'bag 'cup '(coffee cup tea cup and hick cup))
> (multiinsertR 'bag 'cup '(cup tea cup and hick cup))
> >(multiinsertR 'bag 'cup '(tea cup and hick cup))
> > (multiinsertR 'bag 'cup '(cup and hick cup))
> > >(multiinsertR 'bag 'cup '(and hick cup))
> > > (multiinsertR 'bag 'cup '(hick cup))
> > > >(multiinsertR 'bag 'cup '(cup))
> > > > (multiinsertR 'bag 'cup '())
< < < < '()
< < < <'(cup bag)
< < < '(hick cup bag)
< < <'(and hick cup bag)
< < '(cup bag and hick cup bag)
< <'(tea cup bag and hick cup bag)
< '(cup bag tea cup bag and hick cup bag)
<'(coffee cup bag tea cup bag and hick cup bag)
'(coffee cup bag tea cup bag and hick cup bag)

\end{verbatim}

\begin{verbatim}
    (define multiinsertL
      (lambda (new old lat)
        (cond ((null? lat) (quote ()))
              ((eq? old (car lat))
               (cons new (cons (car lat) (multiinsertL new old (cdr lat)))))
              (else (cons (car lat) (multiinsertL new old (cdr lat)))))))

    > (multiinsertL 'bag 'cup '(coffee cup tea cup and hick cup))
>(multiinsertL 'bag 'cup '(coffee cup tea cup and hick cup))
> (multiinsertL 'bag 'cup '(cup tea cup and hick cup))
> >(multiinsertL 'bag 'cup '(tea cup and hick cup))
> > (multiinsertL 'bag 'cup '(cup and hick cup))
> > >(multiinsertL 'bag 'cup '(and hick cup))
> > > (multiinsertL 'bag 'cup '(hick cup))
> > > >(multiinsertL 'bag 'cup '(cup))
> > > > (multiinsertL 'bag 'cup '())
< < < < '()
< < < <'(bag cup)
< < < '(hick bag cup)
< < <'(and hick bag cup)
< < '(bag cup and hick bag cup)
< <'(tea bag cup and hick bag cup)
< '(bag cup tea bag cup and hick bag cup)
<'(coffee bag cup tea bag cup and hick bag cup)
'(coffee bag cup tea bag cup and hick bag cup)

\end{verbatim}

\begin{verbatim}
    (define multisubst
      (lambda (new old lat)
        (cond ((null? lat) (quote ()))
              ((eq? (car lat) old) (cons new (multisubst new old (cdr lat))))
              (else (cons (car lat) (multisubst new old (cdr lat)))))))

> (multisubst 'bag 'cup '(coffee cup tea cup and hick cup))
>(multisubst 'bag 'cup '(coffee cup tea cup and hick cup))
> (multisubst 'bag 'cup '(cup tea cup and hick cup))
> >(multisubst 'bag 'cup '(tea cup and hick cup))
> > (multisubst 'bag 'cup '(cup and hick cup))
> > >(multisubst 'bag 'cup '(and hick cup))
> > > (multisubst 'bag 'cup '(hick cup))
> > > >(multisubst 'bag 'cup '(cup))
> > > > (multisubst 'bag 'cup '())
< < < < '()
< < < <'(bag)
< < < '(hick bag)
< < <'(and hick bag)
< < '(bag and hick bag)
< <'(tea bag and hick bag)
< '(bag tea bag and hick bag)
<'(coffee bag tea bag and hick bag)
'(coffee bag tea bag and hick bag)

\end{verbatim}
\end{itemize}

\textbf{Core Terms/Concepts Learnt}
\begin{itemize}
\item Method to generate lists by using \texttt{cons} in recursions.
\end{itemize}

\newpage

\section{Numbers Games}
\label{sec:org2dfc475}

This chapter explains how numbers can be built with recursion.

\vspace{1em}

Key Takeaway:

\emph{The First Commandment (first revision): When recurring on a list of atoms, \texttt{lat}, asks two questions about it: \texttt{(null? lat)} and \texttt{else}. When recurring on a number, \texttt{n}, ask two questions about it: \texttt{(zero? n)} and \texttt{else}.}

\bigskip

\emph{The Fourth Commandment (first revision): Always change one argument while recurring. It must be changed closer to termination. The changing argument must be tested in the termination condition: when using \texttt{cdr} test termination with null? and when using \texttt{sub1}, test termination with \texttt{zero?}.}

\bigskip

\emph{The Fifth Commandment: When building a value with \texttt{+}, always use 0 for the value of the terminating line, for adding 0 does not change the value of an addition. When building a value with \texttt{x}, always use 1 for the value of the terminating line, for multiplying by 1 does not change the value of a multiplication. When building a value with \texttt{cons}, always consider \texttt{()} for the value of the terminating line.}

\vspace{1em}

\subsection{Addition and Subtraction}
\label{sec:org66f9abd}

\begin{itemize}
\item In this chapter we are focusing on only the elements in the set of whole numbers.
\item We define the basic primitive functions to add 1 or subtract 1. Using this increment or decrement my assumption is we will create the Whole
number set.
\begin{verbatim}
(define add1
  (lambda (n)
    (+ n 1)))

(define sub1
  (lambda (n)
    (- n 1)))

\end{verbatim}
If we do \texttt{(sub1 0)} we will actually get \texttt{-1} but for the sake of the book we will deal only with non-negative integers.
\item \texttt{zero?} is an inbuilt predicate just like \texttt{ZEROP} in Common Lisp.
\item We define addition of two numbers by making a decrementing counter of one of the numbers till it reaches zero. For every decrement we \texttt{add1}
to the other number. So for instance we need to add 3 to 2 then the 3 goes to 2 then 1 then 0. So there are three steps 3 to 2, 2 to 1 and 1
to 0. So these three steps gets added to 2. Thus we get 5. Better to look at the stack trace for the example below. We are using the letter \texttt{o}
to denote that its our `own' definition.
\begin{verbatim}
(define o+
  (lambda (n m)
    (cond ((zero? m) n)
          (else (add1 (o+ n (sub1 m)))))))

\end{verbatim}

\begin{verbatim}
> (o+ 2 3)
>(o+ 2 3)
> (o+ 2 2)
> >(o+ 2 1)
> > (o+ 2 0)
< < 2
< <3
< 4
<5
5

\end{verbatim}

\item In the earlier chapter the authors had referred to using \texttt{(null?)} as the first test and now they correctly say that for numbers we can
use \texttt{zero?} as the test.
\item \texttt{zero?} is like \texttt{null?} and \texttt{add1} is like \texttt{cons}.
\item Exactly like \texttt{o+} we can build \texttt{o-} . The only difference is that we do not \texttt{add1} on every decrement but rather subtract using \texttt{sub1}. Looking
at the stack trace below.
\begin{verbatim}
(define o-
  (lambda (n m)
    (cond ((zero? m) n)
          (else (sub1 (o- n (sub1 m)))))))

> (o- 5 3)
>(o- 5 3)
> (o- 5 2)
> >(o- 5 1)
> > (o- 5 0)
< < 5
< <4
< 3
<2
2

\end{verbatim}
\end{itemize}

\subsection{Tuples}
\label{sec:org7cc3c18}

\begin{itemize}
\item Tuple is defined as a list of numbers. In this case I am assuming non negative numbers and also the book say an empty list will be also a
tuple. I don't think tuple is defined formally in the R\textsuperscript{5}RS standard.
\item \texttt{()} is also a tuple as it is a list of zero numbers.
\item \texttt{addtup} is essentially a function which does digit-sum (sums the numbers in the tuple).
\item We will use \texttt{o+} to build numbers just like \texttt{cons} is used to build lists.
\item Writing \texttt{addtup} seems easy given the exercises prior to this and reading Pof Touretzky. Side comment: This book is actually really fun!
\begin{verbatim}
    (define addtup
      (lambda (tup)
        (cond ((null? tup) 0)
              (else (o+ (car tup) (addtup (cdr tup)))))))

> (addtup '(1 2 3 4 5 6 7 8 9 10))
>(addtup '(1 2 3 4 5 6 7 8 9 10))
> (addtup '(2 3 4 5 6 7 8 9 10))
> >(addtup '(3 4 5 6 7 8 9 10))
> > (addtup '(4 5 6 7 8 9 10))
> > >(addtup '(5 6 7 8 9 10))
> > > (addtup '(6 7 8 9 10))
> > > >(addtup '(7 8 9 10))
> > > > (addtup '(8 9 10))
> > > > >(addtup '(9 10))
> > > > > (addtup '(10))
> > > >[10] (addtup '())
< < < <[10] 0
< < < < < 10
< < < < <19
< < < < 27
< < < <34
< < < 40
< < <45
< < 49
< <52
< 54
<55
55

\end{verbatim}
\end{itemize}

\subsection{Multiplication}
\label{sec:orge4a5c58}

\begin{itemize}
\item Multiplication is repetitive addition. So to build \texttt{x} we have to decrement one number and for every decrement add the other number to itself.
\begin{verbatim}
    (define x
      (lambda (n m)
        (cond ((zero? m) 0)
              (else (o+ n (x n (sub1 m)))))))

> (x 4 3)
>(x 4 3)
> (x 4 2)
> >(x 4 1)
> > (x 4 0)
< < 0
< <4
< 8
<12
12

\end{verbatim}

\item A nice expansion in the book is for \texttt{(x 12 3)} fairly similar to the \texttt{trace} Dr Racket generates.
\begin{verbatim}
(x 12 3)
= 12 + (x 12 2)
= 12 + 12 + (x 12 1)
= 12 + 12 + 12 + (x 12 0)
= 12 + 12 + 12 + 0
= 12 + 24
= 36

\end{verbatim}
\end{itemize}

\subsubsection{Digression to Abstract Algebra}
\label{sec:org8be745b}

\begin{itemize}
\item A question is asked why is 0 the value for the terminal condition line in \texttt{x} and the answer to this is because 0 will not affect \texttt{+}. That
is \texttt{n + 0 = n}. The actual math behind lies in abstract algebra. In an operation such as \texttt{+} there is a concept of identity and inverse. The
\texttt{identity} or \texttt{neutral} element in the set of this operation does not affect the value of other elements when the operation is applied between
an element and this identity. For example, in the operation of \texttt{+} the \texttt{identity} element is \texttt{0}. The operation \texttt{+} say is applied to the set
of non-negative numbers (as done in this book). So \texttt{+} 2 and the \texttt{identity} should yield 2 itself. Thus the identity in this set of whole
numbers for this specific \texttt{+} operation is 0. Similarly for the operation of \texttt{x} in the set of natural numbers the identity is 1. 2 multiplied
by 1 yields 2 again. Now we get back to scheme and away from abstract algebra.

\item The next function we write is addition of two tuples. In this all elements in the tuple at their respective positions are added. The first version
of the code adds two tuples of the same length (code is below). When we supply it with varying length tuples we get an error because it tries to
add a number to an empty list. The trace diagram shows the error. Now we will write a cleaner function which will take varying length tuples.
\begin{verbatim}
; this v1 version will work only if length of tup1 and tup2 is same
    (define tup+v1       
      (lambda (tup1 tup2)
        (cond ((and (null? tup1) (null? tup2)) (quote ()))
              (else (cons (o+ (car tup1) (car tup2))
                          (tup+v1 (cdr tup1) (cdr tup2)))))))

> (tup+v1 '(1 2 3 4) '(4 3 2 1))
>(tup+v1 '(1 2 3 4) '(4 3 2 1))
> (tup+v1 '(2 3 4) '(3 2 1))
> >(tup+v1 '(3 4) '(2 1))
> > (tup+v1 '(4) '(1))
> > >(tup+v1 '() '())
< < <'()
< < '(5)
< <'(5 5)
< '(5 5 5)
<'(5 5 5 5)
'(5 5 5 5)

> (tup+v1 '(1 2 3 4) '(4 3 2))
>(tup+v1 '(1 2 3 4) '(4 3 2))
> (tup+v1 '(2 3 4) '(3 2))
> >(tup+v1 '(3 4) '(2))
> > (tup+v1 '(4) '())
. . car: contract violation
  expected: pair?
  given: '()

\end{verbatim}

\item \texttt{tup+} below is the correct way to define addition of the elements of two tuples. The trace diagram helps understand why. When one of the tuples
runs out of elements i.e. it is an empty tuple, then at that time whatever the present recurring state of the other tuple is that is used for
\texttt{cons}-ing when the stack frames start returning values.
\begin{verbatim}
    (define tup+
      (lambda (tup1 tup2)
        (cond ((null? tup1) tup2)
              ((null? tup2) tup1)
              (else (cons (o+ (car tup1) (car tup2))
                          (tup+ (cdr tup1) (cdr tup2)))))))

> (tup+ '(1 2 3 4) '(4 3 2 1))
>(tup+ '(1 2 3 4) '(4 3 2 1))
> (tup+ '(2 3 4) '(3 2 1))
> >(tup+ '(3 4) '(2 1))
> > (tup+ '(4) '(1))
> > >(tup+ '() '())
< < <'()
< < '(5)
< <'(5 5)
< '(5 5 5)
<'(5 5 5 5)
'(5 5 5 5)

> (tup+ '(1 2 3 ) '(4 3 2 1))
>(tup+ '(1 2 3) '(4 3 2 1))
> (tup+ '(2 3) '(3 2 1))
> >(tup+ '(3) '(2 1))
> > (tup+ '() '(1))
< < '(1)
< <'(5 1)
< '(5 5 1)
<'(5 5 5 1)
'(5 5 5 1)

> (tup+ '(1 2 3 4) '(4 3 2))
>(tup+ '(1 2 3 4) '(4 3 2))
> (tup+ '(2 3 4) '(3 2))
> >(tup+ '(3 4) '(2))
> > (tup+ '(4) '())
< < '(4)
< <'(5 4)
< '(5 5 4)
<'(5 5 5 4)
'(5 5 5 4)

\end{verbatim}
\end{itemize}

\subsection{Comparison operators}
\label{sec:orga3dc4ce}

\begin{itemize}
\item Definitions of greater than and smaller than \texttt{>} and \texttt{<} is tricky. For greater than \texttt{>} the order of tests  matter. The \texttt{\#f} needs to
be tested first for the base condition. This is so because when \texttt{n} reaches zero we know for sure that \texttt{n} is \texttt{<= m} thus the overall test
is \texttt{\#f}. But if we had tested \texttt{m} as zero which would return \texttt{\#t} even if the condition \texttt{=} is satisfied. Similarly we can compose a function
for lesser than \texttt{<}.
\begin{verbatim}
    (define >
      (lambda (n m)
        (cond ((zero? n) #f)
              ((zero? m) #t)
              (else (> (sub1 n) (sub1 m))))))
> (> 3 1)
>(> 3 1)
>(> 2 0)
<#t
#t

> (> 1 4)
>(> 1 4)
>(> 0 3)
<#f
#f

> (> 4 4)
>(> 4 4)
>(> 3 3)
>(> 2 2)
>(> 1 1)
>(> 0 0)
<#f
#f

\end{verbatim}

\begin{verbatim}
    (define <
      (lambda (n m)
        (cond ((zero? m) #f)
              ((zero? n) #t)
              (else (< (sub1 n) (sub1 m))))))

> (< 1 4)
>(< 1 4)
>(< 0 3)
<#t
#t
> (< 4 1)
>(< 4 1)
>(< 3 0)
<#f
#f
> (< 4 4)
>(< 4 4)
>(< 3 3)
>(< 2 2)
>(< 1 1)
>(< 0 0)
<#f
#f

\end{verbatim}
\end{itemize}

\subsection{Equality}
\label{sec:orgdb92c6b}

\begin{itemize}
\item Next we compose the equality function \texttt{=} for numbers. The plain vanilla method is to check if one is zero and whether at the same time the
other is zero too. If not then it is false. Also if one reaches zero while decrementing and the other is still not zero then it is not equal.
The code is simple below. The other way which build up on \texttt{>} and \texttt{<} is to check if these two are false then \texttt{=} will be true.
\begin{verbatim}
(define o=
  (lambda (n m)
    (cond ((zero? m) (zero? n))
          ((zero? n) #f)
          (else (= (sub1 n) (sub1 m))))))

(define =
  (lambda (n m)
    (cond ((> n m) #f)
          ((< n m) #f)
          (else #t))))

\end{verbatim}

\item Exponents (or raising to power) is also simple.
\begin{verbatim}
    (define o^
      (lambda (n m)
        (cond ((zero? m) 1)
              (else (x n (o^ n (sub1 m)))))))

> (o-exp 2 4)
>(o-exp 2 4)
> (o-exp 2 3)
> >(o-exp 2 2)
> > (o-exp 2 1)
> > >(o-exp 2 0)
< < <1
< < 2
< <4
< 8
<16
16

\end{verbatim}
\end{itemize}

\subsection{Division}
\label{sec:orgdc5a3d3}

\begin{itemize}
\item Integer division is implemented smartly by basically figuring out the how many wholes of a number fits into another. Thus discarding any of the
remainder. Wonder how remainder can be obtained via recursion especially for recurring decimals or if I throw an irrational number.
\begin{verbatim}
    (define o-div
      (lambda (n m)
        (cond ((< n m) 0)
              (else (add1 (o-div (o- n m) m))))))
> (o-div 16 3)
>(o-div 16 3)
> (o-div 13 3)
> >(o-div 10 3)
> > (o-div 7 3)
> > >(o-div 4 3)
> > > (o-div 1 3)
< < < 0
< < <1
< < 2
< <3
< 4
<5
5

\end{verbatim}

\item In Common Lisp \texttt{LENGTH} is provided in the common user package as a function but here in Scheme we have to build it ourselves. Its quite easy.
\begin{verbatim}
    (define length
      (lambda (lat)
        (cond ((null? lat) 0)
              (else (add1 (length (cdr lat)))))))

> (length '(gulab jamun ladoo jalebi))
>(length '(gulab jamun ladoo jalebi))
> (length '(jamun ladoo jalebi))
> >(length '(ladoo jalebi))
> > (length '(jalebi))
> > >(length '())
< < <0
< < 1
< <2
< 3
<4
4

\end{verbatim}
\end{itemize}

\subsection{Indexing}
\label{sec:org81e6a6e}

\begin{itemize}
\item Indexing a list or like in Python we refer to elements of a list starting with 0. In this example the book starts indexing with 1. Here I show
both indexes one starting with 0 and the other as in the book starting with 1.
\begin{verbatim}
(define pick-zero
  (lambda (n lat)
    (cond ((zero? n) (car lat))
          (else (pick-zero (sub1 n) (cdr lat))))))

(define pick
  (lambda (n lat)
    (cond ((zero? (sub1 n)) (car lat))
          (else (pick (sub1 n) (cdr lat))))))

    > (pick-zero 2 '(paneer butter masala curry))
    >(pick-zero 2 '(paneer butter masala curry))
    >(pick-zero 1 '(butter masala curry))
    >(pick-zero 0 '(masala curry))
    <'masala
    'masala

    > (pick 2 '(paneer butter masala curry))
    >(pick 2 '(paneer butter masala curry))
    >(pick 1 '(butter masala curry))
    <'butter
    'butter
\end{verbatim}

\item Removing an element in the list is consing like we did before.
\begin{verbatim}
(define rempick
  (lambda (n lat)
    (cond
      ((zero? (sub1 n)) (cdr lat))
      (else (cons (car lat)
                  (rempick (sub1 n) (cdr lat)))))))

\end{verbatim}

\item \texttt{number?} is a primitive in Scheme just like \texttt{NUMERBP} in Common Lisp.
\begin{verbatim}
> (number? 5)
#t
> (number? 'dosa)
#f

\end{verbatim}

\item Removing all numbers from a given list is a combination of using \texttt{number?} and a \texttt{cons} recursion. Unsure why the authors use two \texttt{else}'s. It makes
the function long and a tad bit complicated.
\begin{verbatim}
(define no-nums
  (lambda (lat)
    (cond
      ((null? lat) (quote ()))
      ((number? (car lat)) (no-nums (cdr lat)))
      (else (cons (car lat) (no-nums (cdr lat)))))))

(define no-nums-else
  (lambda (lat)
    (cond
      ((null? lat) (quote ()))
      (else (cond
              ((number? (car lat))
               (no-nums-else (cdr lat)))
              (else (cons (car lat)
                          (no-nums-else (cdr lat)))))))))

\end{verbatim}

\item The next function is inverse of the former \texttt{no-nums}. In this \texttt{all-nums} we keep only the numbers and do away with everything else. This is also simple.
\begin{verbatim}
(define all-nums
  (lambda (lat)
    (cond
      ((null? lat) (quote ()))
      ((number? (car lat)) (cons
                            (car lat) (all-nums (cdr lat))))
      (else (all-nums (cdr lat))))))

\end{verbatim}
\end{itemize}

\subsection{Equality tests in Scheme}
\label{sec:orgd5ffa8b}

\begin{itemize}
\item In Prof Touretzky's book on Common Lisp there is a very nice explanation of equality tests such as \texttt{EQUAL}, \texttt{=}, \texttt{EQ} etc. Similarly in Scheme there are differences
in the way equality tests are done. The table below captures the notes on this topic.

\begin{center}
\begin{tabular}{lll}
Predicate & Meaning & Works On\\[0pt]
\hline
\texttt{eq?} & Object identity - Are these the same objects? & symbols, booleans\\[0pt]
\texttt{eqv?} & Value identity (atomic) - Do these denote the same values? & numbers, chars\\[0pt]
\texttt{equal?} & Structural equality - Are these structurally the same? & lists, strings, etc.\\[0pt]
\texttt{=} & Numeric equality - Are these numbers same? & numbers\\[0pt]
\end{tabular}
\end{center}

\bigskip

\begin{center}
\begin{tabular}{ll}
Predicate & Example\\[0pt]
\hline
\texttt{eq?} & (eq? 'a 'a) → \#t\\[0pt]
\texttt{eqv?} & (eqv? 3 3) → \#t\\[0pt]
\texttt{equal?} & (equal? '(a b) '(a b)) → \#t\\[0pt]
\texttt{=} & (= 3 3.0) → \#t\\[0pt]
\end{tabular}
\end{center}

My assumption is that the \emph{object} refers to the Lisp object therefore it is that specific location in memory which is being compared. Essentially are these two
things in the same memory location? I will need to confirm this. Rest of the equality predicates are straightforward. Test to check the Lisp Object hypothesis:
\begin{verbatim}
> (eq? '(a b) '(a b))
#f
> (equal? '(a b) '(a b))
#t

\end{verbatim}

\item Next we write a function to check if the atoms are same. Here we use \texttt{=} for comparing numbers, and rightly so.
\begin{verbatim}
(define eqan?
  (lambda (a1 a2)
    (cond
      ((and (number? a1) (number? a2))
       (= a1 a2))
      ((or (number? a1) (number? a2)) #f)
      (else (eq? a1 a2)))))

\end{verbatim}

\item Not sure of the answer to the question "Can we assume that all functions written using \texttt{eq?} can be generalized by replacing \texttt{eq?} by \texttt{eqan?}". The answer
given is "Yes" except for \texttt{equan?} itself. Is it because we can't write \texttt{equan?} without \texttt{eq?}. Not sure if I understood this correctly.

\item \texttt{occur} is defined which basically counts the frequency of occurrence in a list.
\begin{verbatim}
(define occur
  (lambda (a lat)
    (cond
      ((null? lat) 0)
      ((eq? a (car lat)) (add1 (occur a (cdr lat))))
      (else (occur a (cdr lat))))))

\end{verbatim}

\item The chapter suddenly jumps to defining \texttt{one?} predicate which essentially checks if a number is \texttt{1} or not. We do it in multiple ways but we learn that \texttt{cond}
is not necessary to construct this predicate.
\begin{verbatim}
(define one-zero?
  (lambda (n)
    (cond
      ((zero? n) #f)
      (else (zero? (sub1 n))))))

(define one-equal?
  (lambda (n)
    (cond
      (else (= n 1)))))

(define one?
  (lambda (n)
    (= n 1)))

\end{verbatim}

\item The last function of the chapter is \texttt{rempick} using \texttt{one?}. This is just a small change to our original \texttt{rempick} function.
\begin{verbatim}
(define rempick-one
  (lambda (n lat)
    (cond
      ((one? n) (cdr lat))
      (else (cons (car lat)
                  (rempick-one (sub1 n) (cdr lat)))))))

\end{verbatim}
\end{itemize}

\textbf{Core Terms/Concepts Learnt}
\begin{itemize}
\item Building numbers by adding or subtracting 1
\item Building primitive arithmetic operations of \texttt{+}, \texttt{-}, \texttt{x} and \texttt{/} (integer)
\item Operations on tuples
\item Different  ways to do equality testing and counting frequency of occurrence
\end{itemize}


\newpage

\section{* Oh My Gawd *: It's Full of Stars}
\label{sec:org9f0243a}

This chapter we start looking at nested lists.

\vspace{1em}

Key Takeaway:

\emph{The First Commandment (final version): When recurring on a list of atoms, \texttt{lat} ask two questions about it \texttt{(null? lat)} and \texttt{else}.}
\emph{When recurring on a number, \texttt{n} ask two questions about it: \texttt{(zero? n)} and \texttt{else}.}
\emph{When recurring on a list of S-expressions, \texttt{l}, ask three questions about it: \texttt{(null? l)}, \texttt{(atom? (car l))}, and \texttt{else}.}

\bigskip

\emph{The Fourth Commandment (final version): Always change at least one argument while recurring. When recurring on a list of atoms, \texttt{lat}, use \texttt{(cdr lat)}. When recurring on a number, \texttt{n}, use \texttt{(sub1 n)}. And when recurring on a list of S-expressions, \texttt{l}, use \texttt{(car l)} and \texttt{(cdr l)} if}
\emph{neither \texttt{(null? l)} nor \texttt{(atom? (car l))} are true. It must be changed to be closer to termination. The changing argument must be tested in the}
\emph{termination condition: When using \texttt{cdr}, test termination with \texttt{null?} and when using \texttt{sub1}, test termination with \texttt{zero?}.}

\bigskip

\emph{The Sixth Commandment: Simplify only after the function is correct.}

\vspace{1em}

\subsection{Surgery on nested lists}
\label{sec:org586359c}

\subsubsection{Removing a member}
\label{sec:org8d97005}

\begin{itemize}
\item Removing a member in a nested list. In earlier chapters we only focused on proper non-nested lists but in this we will look at lists within lists. There could
be any level of nesting theoretically speaking.
\item Any function name with a \texttt{*} at the end basically means application on the entire list. We write \texttt{rember*} which removes a specific element from even nested lists.
The logic is to simply check if the element in the list is an atom and equal to the removable element, if it is then we just do a recursive \texttt{rember*} on the \texttt{cdr} of the list. If it is not equal
then we \texttt{cons} that to the recursive call of the \texttt{cdr} of the list. In the case where the element is a list itself we keep calling the list recursively that is the \texttt{car} and applying the \texttt{rember*}.
It is fairly logical. The \texttt{trace} on the stack actually shows the entire process nicely.
\begin{verbatim}
    (define rember*
      (lambda (a l)
        (cond ((null? l) (quote ()))
              ((atom? (car l))
               (cond ((eq? a (car l)) (rember* a (cdr l)))
                     (else (cons (car l) (rember* a (cdr l))))))
              (else (cons (rember* a (car l))
                          (rember* a (cdr l)))))))

> (rember* 'cup '((coffee) cup ((tea) cup)
                           (and (hick)) cup))
>(rember* 'cup '((coffee) cup ((tea) cup) (and (hick)) cup))
> (rember* 'cup '(coffee))
> >(rember* 'cup '())
< <'()
< '(coffee)
> (rember* 'cup '(cup ((tea) cup) (and (hick)) cup))
> (rember* 'cup '(((tea) cup) (and (hick)) cup))
> >(rember* 'cup '((tea) cup))
> > (rember* 'cup '(tea))
> > >(rember* 'cup '())
< < <'()
< < '(tea)
> > (rember* 'cup '(cup))
> > (rember* 'cup '())
< < '()
< <'((tea))
> >(rember* 'cup '((and (hick)) cup))
> > (rember* 'cup '(and (hick)))
> > >(rember* 'cup '((hick)))
> > > (rember* 'cup '(hick))
> > > >(rember* 'cup '())
< < < <'()
< < < '(hick)
> > > (rember* 'cup '())
< < < '()
< < <'((hick))
< < '(and (hick))
> > (rember* 'cup '(cup))
> > (rember* 'cup '())
< < '()
< <'((and (hick)))
< '(((tea)) (and (hick)))
<'((coffee) ((tea)) (and (hick)))
'((coffee) ((tea)) (and (hick)))

\end{verbatim}
\end{itemize}

\subsubsection{Inserting a member}
\label{sec:org9b60afe}

\begin{itemize}
\item \texttt{insertR*} is also easy to write but the \texttt{trace} for the example shows detailed stack calls for recursion and the true depth can be gauged as to what is happening in the machine.
\begin{verbatim}
    (define insertR*
      (lambda (new old l)
        (cond ((null? l) (quote ()))
              ((atom? (car l))
               (cond ((eq? old (car l))
                      (cons old (cons new (insertR* new old (cdr l)))))
                     (else (cons (car l) (insertR* new old (cdr l))))))
              (else (cons (insertR* new old (car l))
                          (insertR* new old (cdr l)))))))

> (insertR* 'roast 'chuck
            '((how much (wood))
              could
              ((a (wood) chuck))
              (((chuck)))
              (if (a) ((wood chuck)))
              could chuck wood))
>(insertR*
  'roast
  'chuck
  '((how much (wood))
    could
    ((a (wood) chuck))
    (((chuck)))
    (if (a) ((wood chuck)))
    could
    chuck
    wood))
> (insertR* 'roast 'chuck '(how much (wood)))
> >(insertR* 'roast 'chuck '(much (wood)))
> > (insertR* 'roast 'chuck '((wood)))
> > >(insertR* 'roast 'chuck '(wood))
> > > (insertR* 'roast 'chuck '())
< < < '()
< < <'(wood)
> > >(insertR* 'roast 'chuck '())
< < <'()
< < '((wood))
< <'(much (wood))
< '(how much (wood))
> (insertR*
   'roast
   'chuck
   '(could
     ((a (wood) chuck))
     (((chuck)))
     (if (a) ((wood chuck)))
     could
     chuck
     wood))
> >(insertR*
    'roast
    'chuck
    '(((a (wood) chuck)) (((chuck))) (if (a) ((wood chuck))) could chuck wood))
> > (insertR* 'roast 'chuck '((a (wood) chuck)))
> > >(insertR* 'roast 'chuck '(a (wood) chuck))
> > > (insertR* 'roast 'chuck '((wood) chuck))
> > > >(insertR* 'roast 'chuck '(wood))
> > > > (insertR* 'roast 'chuck '())
< < < < '()
< < < <'(wood)
> > > >(insertR* 'roast 'chuck '(chuck))
> > > > (insertR* 'roast 'chuck '())
< < < < '()
< < < <'(chuck roast)
< < < '((wood) chuck roast)
< < <'(a (wood) chuck roast)
> > >(insertR* 'roast 'chuck '())
< < <'()
< < '((a (wood) chuck roast))
> > (insertR*
     'roast
     'chuck
     '((((chuck))) (if (a) ((wood chuck))) could chuck wood))
> > >(insertR* 'roast 'chuck '(((chuck))))
> > > (insertR* 'roast 'chuck '((chuck)))
> > > >(insertR* 'roast 'chuck '(chuck))
> > > > (insertR* 'roast 'chuck '())
< < < < '()
< < < <'(chuck roast)
> > > >(insertR* 'roast 'chuck '())
< < < <'()
< < < '((chuck roast))
> > > (insertR* 'roast 'chuck '())
< < < '()
< < <'(((chuck roast)))
> > >(insertR* 'roast 'chuck '((if (a) ((wood chuck))) could chuck wood))
> > > (insertR* 'roast 'chuck '(if (a) ((wood chuck))))
> > > >(insertR* 'roast 'chuck '((a) ((wood chuck))))
> > > > (insertR* 'roast 'chuck '(a))
> > > > >(insertR* 'roast 'chuck '())
< < < < <'()
< < < < '(a)
> > > > (insertR* 'roast 'chuck '(((wood chuck))))
> > > > >(insertR* 'roast 'chuck '((wood chuck)))
> > > > > (insertR* 'roast 'chuck '(wood chuck))
> > > >[10] (insertR* 'roast 'chuck '(chuck))
> > > >[11] (insertR* 'roast 'chuck '())
< < < <[11] '()
< < < <[10] '(chuck roast)
< < < < < '(wood chuck roast)
> > > > > (insertR* 'roast 'chuck '())
< < < < < '()
< < < < <'((wood chuck roast))
> > > > >(insertR* 'roast 'chuck '())
< < < < <'()
< < < < '(((wood chuck roast)))
< < < <'((a) ((wood chuck roast)))
< < < '(if (a) ((wood chuck roast)))
> > > (insertR* 'roast 'chuck '(could chuck wood))
> > > >(insertR* 'roast 'chuck '(chuck wood))
> > > > (insertR* 'roast 'chuck '(wood))
> > > > >(insertR* 'roast 'chuck '())
< < < < <'()
< < < < '(wood)
< < < <'(chuck roast wood)
< < < '(could chuck roast wood)
< < <'((if (a) ((wood chuck roast))) could chuck roast wood)
< < '((((chuck roast))) (if (a) ((wood chuck roast))) could chuck roast wood)
< <'(((a (wood) chuck roast))
     (((chuck roast)))
     (if (a) ((wood chuck roast)))
     could
     chuck
     roast
     wood)
< '(could
    ((a (wood) chuck roast))
    (((chuck roast)))
    (if (a) ((wood chuck roast)))
    could
    chuck
    roast
    wood)
<'((how much (wood))
   could
   ((a (wood) chuck roast))
   (((chuck roast)))
   (if (a) ((wood chuck roast)))
   could
   chuck
   roast
   wood)
'((how much (wood)) could ((a (wood) chuck roast)) (((chuck roast)))
  (if (a) ((wood chuck roast))) could chuck roast wood)

\end{verbatim}
\item All \texttt{*} functions  work on empty lists, at atom consed onto a list, or a list consed onto a list.  \texttt{*} functions' additional activity is to
recur into the \texttt{car} if required.
\end{itemize}

\subsubsection{Frequency counting}
\label{sec:org591c073}

\begin{itemize}
\item Next we do a frequency counter across a nested list  and write a function called \texttt{occur*}.
\begin{verbatim}
    (define occur*
      (lambda (a l)
      (cond ((null? l) 0)
            ((atom? (car l))
             (cond ((eq? a (car l)) (add1 (occur* a (cdr l))))
                   (else (occur* a (cdr l)))))
            (else (o+ (occur* a (car l)) (occur* a (cdr l)))))))

> (occur* 'banana '((banana)
                    (split ((((banana ice)))
                            (cream (banana))
                            sherbet))
                    (banana)
                    (bread)
                    (banana brandy)))
>(occur*
  'banana
  '((banana)
    (split ((((banana ice))) (cream (banana)) sherbet))
    (banana)
    (bread)
    (banana brandy)))
> (occur* 'banana '(banana))
> >(occur* 'banana '())
< <0
< 1
> (occur*
   'banana
   '((split ((((banana ice))) (cream (banana)) sherbet))
     (banana)
     (bread)
     (banana brandy)))
> >(occur* 'banana '(split ((((banana ice))) (cream (banana)) sherbet)))
> >(occur* 'banana '(((((banana ice))) (cream (banana)) sherbet)))
> > (occur* 'banana '((((banana ice))) (cream (banana)) sherbet))
> > >(occur* 'banana '(((banana ice))))
> > > (occur* 'banana '((banana ice)))
> > > >(occur* 'banana '(banana ice))
> > > > (occur* 'banana '(ice))
> > > > (occur* 'banana '())
< < < < 0
< < < <1
> > > >(occur* 'banana '())
< < < <0
< < < 1
> > > (occur* 'banana '())
< < < 0
< < <1
> > >(occur* 'banana '((cream (banana)) sherbet))
> > > (occur* 'banana '(cream (banana)))
> > > (occur* 'banana '((banana)))
> > > >(occur* 'banana '(banana))
> > > > (occur* 'banana '())
< < < < 0
< < < <1
> > > >(occur* 'banana '())
< < < <0
< < < 1
> > > (occur* 'banana '(sherbet))
> > > (occur* 'banana '())
< < < 0
< < <1
< < 2
> > (occur* 'banana '())
< < 0
< <2
> >(occur* 'banana '((banana) (bread) (banana brandy)))
> > (occur* 'banana '(banana))
> > >(occur* 'banana '())
< < <0
< < 1
> > (occur* 'banana '((bread) (banana brandy)))
> > >(occur* 'banana '(bread))
> > >(occur* 'banana '())
< < <0
> > >(occur* 'banana '((banana brandy)))
> > > (occur* 'banana '(banana brandy))
> > > >(occur* 'banana '(brandy))
> > > >(occur* 'banana '())
< < < <0
< < < 1
> > > (occur* 'banana '())
< < < 0
< < <1
< < 1
< <2
< 4
<5
5

\end{verbatim}
\end{itemize}

\subsubsection{Substituting}
\label{sec:orga558108}

\begin{itemize}
\item Similarly we write the \texttt{*} function for \texttt{subst*}. Nothing additional other than keeping in mind that we have to recur inside \texttt{car} of \texttt{l} also.
\begin{verbatim}
    (define subst*
      (lambda (new old l)
        (cond ((null? l) (quote ()))
              ((atom? (car l))
               (cond ((eq? (car l) old)
                      (cons new (subst* new old (cdr l))))
                     (else (cons (car l)
                                 (subst* new old (cdr l))))))
              (else (cons (subst* new old (car l))
                          (subst* new old (cdr l)))))))

> (subst* 'orange 'banana
          '((banana)
            (split ((((banana ice)))
                    (cream (banana))
                    sherbet))
            (banana)
            (bread)
            (banana brandy)))
>(subst*
  'orange
  'banana
  '((banana)
    (split ((((banana ice))) (cream (banana)) sherbet))
    (banana)
    (bread)
    (banana brandy)))
> (subst* 'orange 'banana '(banana))
> >(subst* 'orange 'banana '())
< <'()
< '(orange)
> (subst*
   'orange
   'banana
   '((split ((((banana ice))) (cream (banana)) sherbet))
     (banana)
     (bread)
     (banana brandy)))
> >(subst*
    'orange
    'banana
    '(split ((((banana ice))) (cream (banana)) sherbet)))
> > (subst* 'orange 'banana '(((((banana ice))) (cream (banana)) sherbet)))
> > >(subst* 'orange 'banana '((((banana ice))) (cream (banana)) sherbet))
> > > (subst* 'orange 'banana '(((banana ice))))
> > > >(subst* 'orange 'banana '((banana ice)))
> > > > (subst* 'orange 'banana '(banana ice))
> > > > >(subst* 'orange 'banana '(ice))
> > > > > (subst* 'orange 'banana '())
< < < < < '()
< < < < <'(ice)
< < < < '(orange ice)
> > > > (subst* 'orange 'banana '())
< < < < '()
< < < <'((orange ice))
> > > >(subst* 'orange 'banana '())
< < < <'()
< < < '(((orange ice)))
> > > (subst* 'orange 'banana '((cream (banana)) sherbet))
> > > >(subst* 'orange 'banana '(cream (banana)))
> > > > (subst* 'orange 'banana '((banana)))
> > > > >(subst* 'orange 'banana '(banana))
> > > > > (subst* 'orange 'banana '())
< < < < < '()
< < < < <'(orange)
> > > > >(subst* 'orange 'banana '())
< < < < <'()
< < < < '((orange))
< < < <'(cream (orange))
> > > >(subst* 'orange 'banana '(sherbet))
> > > > (subst* 'orange 'banana '())
< < < < '()
< < < <'(sherbet)
< < < '((cream (orange)) sherbet)
< < <'((((orange ice))) (cream (orange)) sherbet)
> > >(subst* 'orange 'banana '())
< < <'()
< < '(((((orange ice))) (cream (orange)) sherbet))
< <'(split ((((orange ice))) (cream (orange)) sherbet))
> >(subst* 'orange 'banana '((banana) (bread) (banana brandy)))
> > (subst* 'orange 'banana '(banana))
> > >(subst* 'orange 'banana '())
< < <'()
< < '(orange)
> > (subst* 'orange 'banana '((bread) (banana brandy)))
> > >(subst* 'orange 'banana '(bread))
> > > (subst* 'orange 'banana '())
< < < '()
< < <'(bread)
> > >(subst* 'orange 'banana '((banana brandy)))
> > > (subst* 'orange 'banana '(banana brandy))
> > > >(subst* 'orange 'banana '(brandy))
> > > > (subst* 'orange 'banana '())
< < < < '()
< < < <'(brandy)
< < < '(orange brandy)
> > > (subst* 'orange 'banana '())
< < < '()
< < <'((orange brandy))
< < '((bread) (orange brandy))
< <'((orange) (bread) (orange brandy))
< '((split ((((orange ice))) (cream (orange)) sherbet))
    (orange)
    (bread)
    (orange brandy))
<'((orange)
   (split ((((orange ice))) (cream (orange)) sherbet))
   (orange)
   (bread)
   (orange brandy))
'((orange)
  (split
   ((((orange ice)))
    (cream (orange))
    sherbet))
  (orange)
  (bread)
  (orange brandy))

\end{verbatim}

\item The \texttt{insertL*} is again on the same lines as before. Planning to omit trace flows now since it will take multiple pages.
\begin{verbatim}
    (define insertL*
      (lambda (new old l)
        (cond ((null? l) (quote ()))
              ((atom? (car l))
               (cond ((eq? (car l) old)
                      (cons new (cons old (insertL* new old (cdr l)))))
                     (else (cons (car l) (insertL* new old (cdr l))))))
              (else (cons (insertL* new old (car l))
                          (insertL* new old (cdr l)))))))

> (insertL* 'pecker 'chuck
            '((how much (wood))
              could
              ((a (wood) chuck))
              (((chuck)))
              (if (a) ((would chuck)))
              could chuck wood))
>(insertL*
  'pecker
  'chuck
  '((how much (wood))
    could
    ((a (wood) chuck))
    (((chuck)))
    (if (a) ((would chuck)))
    could
    chuck
    wood))
> (insertL* 'pecker 'chuck '(how much (wood)))
> >(insertL* 'pecker 'chuck '(much (wood)))
> > (insertL* 'pecker 'chuck '((wood)))
> > >(insertL* 'pecker 'chuck '(wood))
> > > (insertL* 'pecker 'chuck '())
< < < '()
< < <'(wood)
> > >(insertL* 'pecker 'chuck '())
< < <'()
< < '((wood))
< <'(much (wood))
< '(how much (wood))
> (insertL*
   'pecker
   'chuck
   '(could
     ((a (wood) chuck))
     (((chuck)))
     (if (a) ((would chuck)))
     could
     chuck
     wood))
> >(insertL*
    'pecker
    'chuck
    '(((a (wood) chuck))
      (((chuck)))
      (if (a) ((would chuck)))
      could
      chuck
      wood))
> > (insertL* 'pecker 'chuck '((a (wood) chuck)))
> > >(insertL* 'pecker 'chuck '(a (wood) chuck))
> > > (insertL* 'pecker 'chuck '((wood) chuck))
> > > >(insertL* 'pecker 'chuck '(wood))
> > > > (insertL* 'pecker 'chuck '())
< < < < '()
< < < <'(wood)
> > > >(insertL* 'pecker 'chuck '(chuck))
> > > > (insertL* 'pecker 'chuck '())
< < < < '()
< < < <'(pecker chuck)
< < < '((wood) pecker chuck)
< < <'(a (wood) pecker chuck)
> > >(insertL* 'pecker 'chuck '())
< < <'()
< < '((a (wood) pecker chuck))
> > (insertL*
     'pecker
     'chuck
     '((((chuck))) (if (a) ((would chuck))) could chuck wood))
> > >(insertL* 'pecker 'chuck '(((chuck))))
> > > (insertL* 'pecker 'chuck '((chuck)))
> > > >(insertL* 'pecker 'chuck '(chuck))
> > > > (insertL* 'pecker 'chuck '())
< < < < '()
< < < <'(pecker chuck)
> > > >(insertL* 'pecker 'chuck '())
< < < <'()
< < < '((pecker chuck))
> > > (insertL* 'pecker 'chuck '())
< < < '()
< < <'(((pecker chuck)))
> > >(insertL* 'pecker 'chuck '((if (a) ((would chuck))) could chuck wood))
> > > (insertL* 'pecker 'chuck '(if (a) ((would chuck))))
> > > >(insertL* 'pecker 'chuck '((a) ((would chuck))))
> > > > (insertL* 'pecker 'chuck '(a))
> > > > >(insertL* 'pecker 'chuck '())
< < < < <'()
< < < < '(a)
> > > > (insertL* 'pecker 'chuck '(((would chuck))))
> > > > >(insertL* 'pecker 'chuck '((would chuck)))
> > > > > (insertL* 'pecker 'chuck '(would chuck))
> > > >[10] (insertL* 'pecker 'chuck '(chuck))
> > > >[11] (insertL* 'pecker 'chuck '())
< < < <[11] '()
< < < <[10] '(pecker chuck)
< < < < < '(would pecker chuck)
> > > > > (insertL* 'pecker 'chuck '())
< < < < < '()
< < < < <'((would pecker chuck))
> > > > >(insertL* 'pecker 'chuck '())
< < < < <'()
< < < < '(((would pecker chuck)))
< < < <'((a) ((would pecker chuck)))
< < < '(if (a) ((would pecker chuck)))
> > > (insertL* 'pecker 'chuck '(could chuck wood))
> > > >(insertL* 'pecker 'chuck '(chuck wood))
> > > > (insertL* 'pecker 'chuck '(wood))
> > > > >(insertL* 'pecker 'chuck '())
< < < < <'()
< < < < '(wood)
< < < <'(pecker chuck wood)
< < < '(could pecker chuck wood)
< < <'((if (a) ((would pecker chuck))) could pecker chuck wood)
< < '((((pecker chuck)))
      (if (a) ((would pecker chuck)))
      could
      pecker
      chuck
      wood)
< <'(((a (wood) pecker chuck))
     (((pecker chuck)))
     (if (a) ((would pecker chuck)))
     could
     pecker
     chuck
     wood)
< '(could
    ((a (wood) pecker chuck))
    (((pecker chuck)))
    (if (a) ((would pecker chuck)))
    could
    pecker
    chuck
    wood)
<'((how much (wood))
   could
   ((a (wood) pecker chuck))
   (((pecker chuck)))
   (if (a) ((would pecker chuck)))
   could
   pecker
   chuck
   wood)
'((how much (wood))
  could
  ((a (wood) pecker chuck))
  (((pecker chuck)))
  (if (a) ((would pecker chuck)))
  could
  pecker
  chuck
  wood)

\end{verbatim}
\item Writing a \texttt{member*} is also fairly simple. I think so far recursion has been ingrained into this book solvers mind!
The trace diagram shows which \texttt{chips} the function found. That is important.
\begin{verbatim}
    (define member*
     (lambda (a l)
       (cond ((null? l) #f)
             ((atom? (car l))
              (or (eq? (car l) a)
                  (member* a (cdr l))))
             (else (or (member* a (car l))
                       (member* a (cdr l)))))))

> (member* 'chips '((potato) (chips ((with) fish) (chips))))
>(member* 'chips '((potato) (chips ((with) fish) (chips))))
> (member* 'chips '(potato))
> (member* 'chips '())
< #f
>(member* 'chips '((chips ((with) fish) (chips))))
> (member* 'chips '(chips ((with) fish) (chips)))
< #t
<#t
#t

\end{verbatim}

\item \texttt{leftmost} recurs only on the \texttt{car} looking for the atom in a non-empty list.
\begin{verbatim}
  (define leftmost
    (lambda (l)
      (cond ((atom? (car l)) (car l))
            (else (leftmost (car l))))))

> (leftmost '((potato) (chips ((with) fish) (chips))))
>(leftmost '((potato) (chips ((with) fish) (chips))))
>(leftmost '(potato))
<'potato
'potato

\end{verbatim}
\end{itemize}

\subsection{\texttt{and} vs \texttt{or}}
\label{sec:org06de401}

\begin{itemize}
\item Again the distinction between \texttt{and} and \texttt{or} is made. For \texttt{and} if the any of the expressions evaluates to \texttt{\#f} then further evaluation
stops. In \texttt{or} the evaluation stops the moment we find a \texttt{\#t}.
\item In a footnote a very important property of \texttt{cond} is highlighted (mentioned earlier in this booklet also). \texttt{cond} does not consider all of its arguments. It essentially
goes through a sequence from top to bottom. Prof Touretzky's book has a crystal clear explanation on this. In this book the authors state that neither \texttt{and} nor \texttt{or} can
be stated as functions using \texttt{cond} though both can be expressed as abbreviations of \texttt{cond}.
\begin{verbatim}
(and a b) = (cond (a b) else #f)
(or a b) = (cond (a #t) (else b))
\end{verbatim}

\item The function \texttt{eqlist?} is written to compare the elements of two lists. The first attempt is rather elaborate building from first logical principles.
But the second is concise. Here I write the second version.
\begin{verbatim}
    (define eqlist?
      (lambda (l1 l2)
        (cond ((and (null? l1) (null? l2)) #t)
              ((or (null? l1) (null? l2)) #f)
              ((and (atom? (car l1)) (atom? (car l2)))
               (and (eqan? (car l1) (car l2))
                    (eqlist? (cdr l1) (cdr l2))))
              ((or (atom? (car l1)) (atom? (car l2))) #f)
              (else (eqlist? (car l1) (car l2))
                    (eqlist? (cdr l1) (cdr l2))))))

> (eqlist? '(aloo ((matar)) (and (gobhi)))
           '(aloo ((matar)) and (gobhi)))
>(eqlist? '(aloo ((matar)) (and (gobhi))) '(aloo ((matar)) and (gobhi)))
>(eqlist? '(((matar)) (and (gobhi))) '(((matar)) and (gobhi)))
> (eqlist? '((matar)) '((matar)))
> >(eqlist? '(matar) '(matar))
> >(eqlist? '() '())
< <#t
> (eqlist? '() '())
< #t
>(eqlist? '((and (gobhi))) '(and (gobhi)))
<#f
#f

> (eqlist? '(aloo ((matar)) (and (gobhi)))
           '(aloo ((gajar)) and (gobhi)))
>(eqlist? '(aloo ((matar)) (and (gobhi))) '(aloo ((gajar)) and (gobhi)))
>(eqlist? '(((matar)) (and (gobhi))) '(((gajar)) and (gobhi)))
> (eqlist? '((matar)) '((gajar)))
> >(eqlist? '(matar) '(gajar))
< <#f
> (eqlist? '() '())
< #t
>(eqlist? '((and (gobhi))) '(and (gobhi)))
<#f
#f

\end{verbatim}
\item The book reiterates the definition of S-expression again: It is an atom or a (possibly empty) list of S-expressions.
\item Here I think is the turning point of the book. I think the basics are behind us now.
\item The function \texttt{equal?} is written using \texttt{eqlist?}. I am calling it \texttt{my-equal?} since \texttt{equal?} is built in to the language. The catch is now
\texttt{my-equal?} is comparing two S-expressions and not just atoms. 
\begin{verbatim}
(define my-equal?
  (lambda (s1 s2)
    (cond ((and (atom? s1) (atom? s2)) (eqan? s1 s2))
          ((or (atom? s1) (atom? s2)) #f)
          (else (eqlist? s1 s2)))))

(define eqlist-equal?
  (lambda (l1 l2)
    (cond ((and (null? l1) (null? l2)) #t)
          ((or (null? l1) (null? l2)) #f)
          (else (and (my-equal? (car l1) (car l2)))
                (eqlist-equal? (cdr l1) (cdr l2))))))

\end{verbatim}

\item \texttt{rember} is written so that it operates on an S-expression. The original function on a list of atoms was elegant itself.
 But the good part is we are now operating on S-expressions rather than atoms.
Anyways here is the function
\begin{verbatim}
(define rember-equal
  (lambda (s l)
    (cond
      ((null? l) (quote ()))
      ((equal? (car l) s) (cdr l))
      (else (cons (car l)
                  (rember-equal s (cdr l)))))))

\end{verbatim}

\item We cannot simplify \texttt{insertL*} because this function actually needs to look at atoms specifically.
\item The last question in the chapter is important. We should know which comparison predicate we need to use when. The table which I have in the previous chapter is good for that.
\end{itemize}

\textbf{Core Terms/Concepts Learnt}
\begin{itemize}
\item Able to recur in the \texttt{car}.
\item All comparison operators in the language (sort of)
\texttt{eq?}, \texttt{=}, \texttt{equal} primarily.
\item Recurring over a list of atoms vs S-expressions.
\end{itemize}


\newpage

\section{Shadows}
\label{sec:org5aa612a}

Names can hide other names. Environments matter.

\vspace{1em}

Key Takeaway:

\emph{The Seventh Commandment: Recur on the sub-parts that are of the same nature: 1) On the sub-lists of a list, 2) On the sub-expressions of an arithmetic expression.}

\bigskip

\emph{The Eight Commandment: Use help functions to abstract from representations.}

\vspace{1em}

\subsection{Symbols and Environments}
\label{sec:org3f708ba}

\begin{itemize}
\item We enter the realm of what symbols actually mean. A \texttt{+} may mean just a symbol and not an operation of addition. So we may have a traditional arithmetic operation of \texttt{2 + 4 x 5} which is
an arithmetic expression. But this expression \texttt{2 + 4 x 5} can be bound to a symbol \texttt{cookie}. Thus \texttt{cookie} is also an arithmetic expression.
\begin{verbatim}
(define cookie 12)
\end{verbatim}

\item The context or the environment matters.
\item A traditional \texttt{(n + 5)} is not considered an arithmetic expression since the parenthesis is not included in the definition of arithmetic expressions.
\item But \texttt{(n + 5)} is an S-expression. Therefore we can use it as an argument to a function. So how do we represent \texttt{3 + 4 x 5}? By \texttt{(3 + ( 4 x 5))}.
\item \texttt{numbered?} is a function that determines if a representation of an arithmetic expressions contains only numbers apart from +, x, exponential (\texttt{o\textasciicircum{}}).
It is not actually evaluating the arithmetic expression.
\item The function \texttt{numbered?} is basically checking for the structural object of an arithmetic expression. I believe this is the early part of an interpreter.
\item The authors explicitly call out that \texttt{(1 + 4)} is not a list but in a list form.
\item I have not yet come across the reason why subtraction or division are not included in this basic interpretation of arithmetic expressions. Perhaps going into
negative integers and for division going into the realm of decimals (floating points).
\item The first question asked in \texttt{numbered?} is whether all arithmetic expressions that are atoms are numbers or not. But why could not we only ask if it is a number only?
\item Now we can take a first stab at writing the \texttt{numbered?} function
\begin{verbatim}
(define numbered-long?
  (lambda (aexp)
    (cond ((atom? aexp) (number? aexp))
          ((eq? (car (cdr aexp)) (quote o+))
           (and (numbered-long? (car aexp))
                (numbered-long? (car (cdr (cdr aexp))))))
          ((eq? (car (cdr aexp)) (quote o*))
           (and (numbered-long? (car aexp))
                (numbered-long? (car (cdr (cdr aexp))))))
          ((eq? (car (cdr aexp)) (quote o^))
           (and (numbered-long? (car aexp))
                (numbered-long? (car (cdr (cdr aexp)))))))))

(define numbered?
  (lambda (aexp)
    (cond ((atom? aexp) (number? aexp))
          (else (and (numbered? (car aexp))
                     (numbered? (car (cdr (cdr aexp)))))))))

\end{verbatim}
\item \texttt{value} is a function which returns the natural value of a numbered arithmetic expression. In the book the operations are limited to addition, multiplication and exponents. No error handling or any
other arithmetic operation. It is fine since the intent is to get conceptual clarity and not go for a full blown interpreter.
\begin{verbatim}
    (define value
      (lambda (nexp)
        (cond ((atom? nexp) nexp)
              ((eq? (car (cdr nexp)) (quote +))
               (o+ (value (car nexp))
                   (value (car (cdr (cdr nexp))))))
              ((eq? (car (cdr nexp)) (quote x))
               (o* (value (car nexp))
                   (value (car (cdr (cdr nexp))))))
              (else
               (o^ (value (car nexp))
                   (value (car (cdr (cdr nexp)))))))))

> (value '((2 + 5) x (4 x 2)))
>(value '((2 + 5) x (4 x 2)))
> (value '(2 + 5))
> >(value 2)
< <2
> >(value 5)
< <5
< 7
> (value '(4 x 2))
> >(value 4)
< <4
> >(value 2)
< <2
< 8
<56
56

\end{verbatim}
\item A wrong version of \texttt{value} for a prefix notation syntax is written and the concept of helper functions is introduced. The helper functions will pick the sub expressions.
This is so because in the incorrect value function for prefix notation is wrong because it ends up with a subpart which is not an arithmetic expression. Even the operator
can be got with a helper function easily. For the normal notation also these helper functions can be changed (earlier code on this).
\begin{verbatim}
(define 1st-sub-exp
  (lambda (aexp)
    (car (cdr aexp))))

(define 2nd-sub-exp
  (lambda (aexp)
    (car (cdr (cdr aexp)))))

(define operator
  (lambda (aexp)
    (car aexp)))

\end{verbatim}
\item Finally writing the function \texttt{value} with help of helper functions.
\begin{verbatim}
    (define value-help
      (lambda (nexp)
        (cond ((atom? nexp) nexp)
              ((eq? (operator nexp) (quote +))
               (o+ (value-help (1st-sub-exp nexp))
                   (value-help (2nd-sub-exp nexp))))
              ((eq? (operator nexp) (quote x))
               (o* (value-help (1st-sub-exp nexp))
                   (value-help (2nd-sub-exp nexp))))
              (else
               (o^ (value (1st-sub-exp nexp))
                   (value (2nd-sub-exp nexp)))))))

> (value-help '(+ 24 25))
49

\end{verbatim}
\end{itemize}

\subsubsection{Representations}
\label{sec:org2516f6f}

\begin{itemize}
\item The idea of representations is explicitly stated. \texttt{4} can be stated as say for instance \texttt{(() () () ())} or even \texttt{(I V)}. The book extends
the same representations for a few natural numbers. It is self explanatory.
\item We write a function called \texttt{sero?} for the representation of numbers in terms of \texttt{()} (same example as above). We also write \texttt{edd1} and \texttt{zub1}.
The authors have given such an elegant example of representation here.
\begin{verbatim}
(define sero?
  (lambda (n)
    (null? n)))

(define edd1
  (lambda (n)
    (cons (quote ()) n)))

(define zub1
  (lambda (n)
    (cdr n)))

\end{verbatim}
\item A \texttt{(zub1 n)} on \texttt{()} as \texttt{n} will give no answer as per the book. Theoretically speaking (negative numbers we would not be able to reproduce).
\item Let us write \texttt{o+rep}.
\begin{verbatim}
(define o+rep
  (lambda n m
    (cond ((sero? m) n)
          (else (edd1 (o+rep n (zub1 m)))))))

\end{verbatim}
\item The last two questions for the checking whether the new representation of \texttt{4} in parenthesis terms is a \texttt{lat?} or not. We must be aware of shadows because
new binding of a variable hides the old binding.The interpreter looks for the nearest binding first.
\begin{verbatim}
> (lat? '((()) (()()) (()()()())))
#f> (lat? '((()) (()()) (()()()())))
#f

\end{verbatim}
\end{itemize}

\textbf{Core Terms/Concepts Learnt}
\begin{itemize}
\item Names are not their values, the environment determines the meaning. Meaning of symbol depends on the current context/environment.
\item Expressions can represent numbers. Representation and value of an arithmetic expression is showing what it is and what value it evaluates to.
\item Recurring over a list of atoms vs S-expressions.
\item Rebinding names hides or shadows previous meanings. \emph{You must be aware of shadows.}
\end{itemize}


\newpage

\section{Friends and Relations}
\label{sec:orgd7a7497}

Working with relations and symbolic computation. Manipulate lists of symbols and represent structured data.

\vspace{1em}

Key Takeaway:

\emph{Sets and set operations: Building and testing them.}

\bigskip

\emph{Relations, Pairs and One-to-One Functions: Defining them.}

\vspace{1em}

\subsection{Sets and Operations}
\label{sec:org5b4d089}

\begin{itemize}
\item \texttt{set?} is exactly like the mathematical set in set theory. The book at the end also recommends Naive Set Theory as an interesting read by the great Paul Halmos.
I own a copy but I am yet to read. The other book I like is Book of Proof by Richard Hammack.
\item A set has unique elements. No element in the set repeats.
\item An empty list \texttt{()} has no atoms. Thus nothing repeats and therefore this is a set too.
\end{itemize}

\subsubsection{Set test}
\label{sec:org4a259ac}

\begin{itemize}
\item Writing \texttt{set?} is fairly easy
\begin{verbatim}
    (define set?
      (lambda (lat)
        (cond ((null? lat) #t)
              ((member? (car lat) (cdr lat)) #f)
              (else (set? (cdr lat))))))

> (set? '(pani puri gol guppa phucka pani))
>(set? '(pani puri gol guppa phucka pani))
<#f
#f
> (set? '(pani puri gol guppa phucka))
>(set? '(pani puri gol guppa phucka))
>(set? '(puri gol guppa phucka))
>(set? '(gol guppa phucka))
>(set? '(guppa phucka))
>(set? '(phucka))
>(set? '())
<#t
#t

\end{verbatim}
\end{itemize}

\subsubsection{Build a set}
\label{sec:org5414f5f}

\begin{itemize}
\item Next we build sets. First we write \texttt{makeset} using \texttt{member?} and then with \texttt{multirember}. There is a difference between the two methods.
In using \texttt{member?} we go through each atom on the list one by one and only consing that when it is not in the rest of the list. It is
building using a predicate test actually.  While using \texttt{multirember} we first build a list and that list is build by removing the elements
given to the \texttt{makeset} function. Trace should show the flow cleanly.
\begin{verbatim}
    (define makeset
      (lambda (lat)
        (cond ((null? lat) (quote ()))
              ((member? (car lat) (cdr lat))
               (makeset (cdr lat)))
              (else (cons (car lat) (makeset (cdr lat)))))))

> (makeset '(apple peach pear peach
                   plum apple lemon peach))
>(makeset '(apple peach pear peach plum apple lemon peach))
>(makeset '(peach pear peach plum apple lemon peach))
>(makeset '(pear peach plum apple lemon peach))
> (makeset '(peach plum apple lemon peach))
> (makeset '(plum apple lemon peach))
> >(makeset '(apple lemon peach))
> > (makeset '(lemon peach))
> > >(makeset '(peach))
> > > (makeset '())
< < < '()
< < <'(peach)
< < '(lemon peach)
< <'(apple lemon peach)
< '(plum apple lemon peach)
<'(pear plum apple lemon peach)
'(pear plum apple lemon peach)

\end{verbatim}

\begin{verbatim}
    (define makeset-multirember
      (lambda (lat)
        (cond ((null? lat) (quote ()))
              (else
               (cons (car lat)
                     (makeset-multirember
                      (multirember (car lat) (cdr lat))))))))

> (makeset-multirember '(apple peach pear peach
                               plum apple lemon peach))
>(makeset-multirember '(apple peach pear peach plum apple lemon peach))
> (makeset-multirember '(peach pear peach plum lemon peach))
> >(makeset-multirember '(pear plum lemon))
> > (makeset-multirember '(plum lemon))
> > >(makeset-multirember '(lemon))
> > > (makeset-multirember '())
< < < '()
< < <'(lemon)
< < '(plum lemon)
< <'(pear plum lemon)
< '(peach pear plum lemon)
<'(apple peach pear plum lemon)
'(apple peach pear plum lemon)

\end{verbatim}

\item Additionally testing \texttt{makeset} on data which has numbers.
\begin{verbatim}
> (makeset '(apple 3 pear 4 9 apple 3 4))
'(pear 9 apple 3 4)

> (makeset-multirember '(apple 3 pear 4 9 apple 3 4))
>(makeset-multirember '(apple 3 pear 4 9 apple 3 4))
> (makeset-multirember '(3 pear 4 9 3 4))
> >(makeset-multirember '(pear 4 9 4))
> > (makeset-multirember '(4 9 4))
> > >(makeset-multirember '(9))
> > > (makeset-multirember '())
< < < '()
< < <'(9)
< < '(4 9)
< <'(pear 4 9)
< '(3 pear 4 9)
<'(apple 3 pear 4 9)
'(apple 3 pear 4 9)

\end{verbatim}
\end{itemize}

\subsubsection{Subsets}
\label{sec:org59e0caa}

\begin{itemize}
\item \texttt{subset?} is a test to check if one set is a part of the other set. Each element of the first set should be present in the other
set for it to be called a subset. This is elementary set theory.
\begin{verbatim}
(define subset?
  (lambda (set1 set2)
    (cond ((null? set1) #t)
          ((member? (car set1) set2)
           (subset? (cdr set1) set2))
          (else #f))))

\end{verbatim}
The book asks us to write \texttt{subset?} with an \texttt{and} also. At first we might think why but I am guessing the authors will drive home the
point at a later point in time.
\begin{verbatim}
(define subset-and?
  (lambda (set1 set2)
    (cond ((null? set1) #t)
          (else (and (member? (car set1) set2)
                     (subset-and? (cdr set1) set2))))))

\end{verbatim}
\end{itemize}


\subsubsection{Equality of sets}
\label{sec:orgd6a2ad4}

\begin{itemize}
\item Next is the test to see if the sets are exactly the same. We can actually just check is the first set is the subset of the second one
and the second set is also the subset of the first one. If both are true then we can say they are equal sets. Also we truly just need
one \texttt{and} test that is all. No \texttt{cond} or anything in this case. I guess this is like anonymous functions perhaps. This is probably the
first function we have written without \texttt{cond} so far.
\begin{verbatim}
(define eqset?
  (lambda (set1 set2)
    (and (subset? set1 set2)
         (subset? set2 set1))))

\end{verbatim}
\end{itemize}


\subsubsection{Intersection of sets}
\label{sec:org33b80cf}

\begin{itemize}
\item The predicate \texttt{intersect?} simply checks if the any of the elements in the first set is present in the other set or not. The book asks us
to simplify and also use \texttt{or} but to me without the \texttt{or} looks more clean and elegant. With \texttt{or} we simply push the last two tests of the cond
with an \texttt{or} in the else leg.
\begin{verbatim}
(define intersect?
  (lambda (set1 set2)
    (cond ((null? set1) #f)
          ((member? (car set1) set2) #t)
          (else (intersect? (cdr set1) set2)))))

\end{verbatim}

\item \texttt{intersect} basically returns the elements which are common in the two sets.
\begin{verbatim}
(define intersect
  (lambda (set1 set2)
    (cond ((null? set1) (quote ()))
          ((member? (car set1) set2)
           (cons (car set1) (intersect (cdr set1) set2)))
          (else (intersect (cdr set1) set2)))))

\end{verbatim}
\end{itemize}

\subsubsection{Union of sets}
\label{sec:org4a79fda}

\begin{itemize}
\item \texttt{union} picks all the elements across the two sets without repeating the intersect elements. It is exactly the same as union in set theory.
\begin{verbatim}
(define union
  (lambda (set1 set2)
    (cond ((null? set1) set2)
          ((member? (car set1) set2)
           (union (cdr set1) set2))
          (else (cons (car set1)
                      (union (cdr set1) set2))))))

> (union '(a b) '(a c d))
>(union '(a b) '(a c d))
>(union '(b) '(a c d))
> (union '() '(a c d))
< '(a c d)
<'(b a c d)
'(b a c d)

\end{verbatim}
\end{itemize}

\subsubsection{Difference of sets}
\label{sec:org614b988}

\begin{itemize}
\item This function is the difference in the two sets. Compared to \texttt{union} the only change is that when the first set is null then we return an empty list
rather than the second list.
\begin{verbatim}
(define set-difference
  (lambda (set1 set2)
    (cond ((null? set1) (quote ()))
          ((member? (car set1) set2)
           (set-difference (cdr set1) set2))
          (else (cons (car set1)
                      (set-difference (cdr set1) set2))))))

\end{verbatim}

\item This section of the chapter is interesting as we will get introduced to the concepts of pairs, relations, functions, one to one relationships. The authors say
so much with so little. This is indeed a deep book and requires multiple readings. I am certain if I start reading from the beginning again I will learn even more things.
Additionally, we need to keep referencing other material at the same time.

\item The function \texttt{intersectall} is written very smartly! It looks at a list of lists and finds common intersection across all the lists.
\begin{verbatim}
    (define intersectall ;;smart function!
      (lambda (l-set)
        (cond ((null? (cdr l-set)) (car l-set))
              (else (intersect (car l-set)
                               (intersectall (cdr l-set)))))))

> (intersectall '((a b c) (c a d e) (e f g h a b)))
>(intersectall '((a b c) (c a d e) (e f g h a b)))
> (intersectall '((c a d e) (e f g h a b)))
> >(intersectall '((e f g h a b)))
< <'(e f g h a b)
< '(a e)
<'(a)
'(a)

\end{verbatim}
\end{itemize}

\subsection{\texttt{pairs}}
\label{sec:orgdbfdcd0}

\begin{itemize}
\item Now we come to one of the most important things in Lisp in general - a pair. In Lisp a pair is the most fundamental data structure. It is created with the function \texttt{cons},
which stands for \emph{construct}.
\begin{verbatim}
> (cons 'a 'b)
'(a . b)

\end{verbatim}

The `a' is the \texttt{car} and `b' is \texttt{cdr}. When the \texttt{cdr} is the null list \texttt{()} then we get the list data structure. The book says a list with two atoms is a pair. That is correct
but in this case the it is a special form of the pair as mentioned in the previous statement. Even a list of two S-expressions is a pair.

\item The code definition of a \texttt{pair?} is quite good.
\begin{verbatim}
(define a-pair?  ;;reason out each line of cond
  (lambda (x)
    (cond
      ((atom? x) #f) ;; there is not a single element
      ((null? x) #f) ;; the list is not empty
      ((null? (cdr x)) #f) ;; the list does not have only one element
      ((null? (cdr (cdr x))) #t) ;; there is no third or more element
                                 ;;i.e. now we have exactly 2 elements
      (else #f)))) ;; everything else is not a pair

\end{verbatim}

\item The book talks about how to build a pair exactly like I mentioned earlier. Also how to get the first and second element. In Common Lisp (Prof Touretzky's book) it
was also demonstrated exactly in this manner but right at the start of the book essentially. These functions are used to make representations of pairs and to get
parts of representations of pairs. They will improve readability.
\begin{verbatim}
(define my-first
  (lambda (p)
    (cond
      (else (car p)))))

(define my-second
  (lambda (p)
    (cond
      (else (car (cdr p))))))

(define my-third ;; not applicable to pairs but in general for a list
  (lambda (p)
    (cond
      (else (car (cdr (cdr p)))))))

(define build
  (lambda (s1 s2)
    (cond
      (else (cons s1 (cons s2 (quote ())))))))

\end{verbatim}

\item We truly do not need \texttt{cond} in the definition of \texttt{first}, \texttt{second} or \texttt{third}. For instance
\begin{verbatim}
(define my-third-nocond
  (lambda (p)
    (car (cdr (cdr p)))))

\end{verbatim}
\end{itemize}

\subsection{Relations}
\label{sec:orgdbc8dc4}

\begin{itemize}
\item \texttt{rel} is a relation. Relations are between a set of pairs. This again originates from the concept of relations in set theory. A pair can be
ordered or unordered. In unordered pairs \texttt{(a b)} is same as \texttt{(b a)}. But in ordered pair these two are different. A relation from one set to another
is a forming of a pair where one element from the first element is taken and the second element of the pair is got from the second set. This is what
we call a relationship. Now if that relation has a constraint that the first element is mapped to exactly one element in the second set then we say it
is a function. So function is a one to one relationship pair between two sets.

\item The book smartly defines functions as a special case of relations by saying that the first element of the pairs should be a set essentially meaning that
there is one to element in first set which maps uniquely to a second element in the second set. A first element mapping to two elements in second set is not
a function.
\begin{verbatim}
(define fun?
  (lambda (rel)
    (set? (firsts rel))))

\end{verbatim}

\item The next function is reversing the elements within a relation. Here we see the usefulness of \texttt{build}, \texttt{first},and  \texttt{second}. Helper functions make code look clean
and flow logically.
\begin{verbatim}
(define revrel
  (lambda (rel)
    (cond ((null? rel) (quote ()))
          (else (cons (build
                       (second (car rel))
                       (first (car rel)))
                      (revrel (cdr rel)))))))

\end{verbatim}
\end{itemize}

\subsubsection{Reversing a \texttt{pair}}
\label{sec:org57bb38e}

\begin{itemize}
\item Another helper function can be written which simply reverses a pair.
\begin{verbatim}
(define revpair
  (lambda (pair)
    (build (second pair) (first pair))))

(define revrel-revpair
  (lambda (rel)
    (cond ((null? rel) (quote ()))
          (else (cons (revpair (car rel))
                      (revrel-revpair (cdr rel)))))))

\end{verbatim}
\end{itemize}

\subsubsection{One to One relations}
\label{sec:org5305992}

\begin{itemize}
\item Finally we reach the one-to-one function. In set theory this is a function (meaning that each of the element from first set i.e. the domain uniquely maps to an element in the second set i.e. the co-domain) which is one-to-one.
By this we mean that each element in the second set i.e. the co-domain maps to exactly one element in the first set i.e. the domain. Therefore there is a one-to-one mapping from domain to co-domain and vice versa.
\begin{verbatim}
(define fullfun?
  (lambda (fun)
    (set? (seconds fun))))

(define one-to-one?
  (lambda (fun)
    (fun? (revrel fun))))

\end{verbatim}

\item The last page of this chapter looks like a fun thing but there is probably a lesson or two in this. First the lambda does not take any arguments so this is a procedure when called will execute a certain steps without any external
influence in terms of arguments. Next we can see the sequence of multiple mixes and cream. So we actually know from the various indentations when that specific mix is done. So in a Lisp program we can communicate ideas in sequences
and not be worried about instructing the computer but rather use it as a medium to communicate ideas.
\end{itemize}

\textbf{Core Terms/Concepts Learnt}
\begin{itemize}
\item Sets, Relations, Pairs, Functions, One-to-one functions
\item Set operations such as intersection, union, difference, subset
\item Use of helper functions
\end{itemize}

\newpage

\section{Lambda the Ultimate}
\label{sec:orgd220956}

Introduce anonymous functions and higher order design. \texttt{lambdas} encapsulate behavior and enable abstraction without naming.

\bigskip

Key Takeaway:

\emph{The Ninth Commandment: Abstract common patterns with a new function.}

\bigskip

\emph{The Tenth Commandment: Build functions to collect more than one value at a time.}

\vspace{1em}

\begin{itemize}
\item This is an important chapter and I will try and make the notes as detailed as possible and have subsections for each concepts covered.
\end{itemize}

\subsection{Higher Order Functions}
\label{sec:org5ad3a51}

\subsubsection{Passing a Function as an Argument}
\label{sec:org6cea3ca}

\begin{itemize}
\item We re-look at the function to remove a member \texttt{rember} with the test being executed by \texttt{equal}. The learning is that we can create another function \texttt{rember-f} which takes in a function additionally
as an argument and applies it to the \texttt{rember} function. We are learning to pass functions to functions perhaps here.
\item We have 4 functions now which do similar things now \texttt{rember} with \texttt{=}, \texttt{eq?}, and \texttt{equal?}, and the one which we write now \texttt{rember-f}.
\begin{verbatim}
(define rember-f1
  (lambda (test? a l)
    (cond
      ((null? l) (quote ()))
      ((test? a (car l)) (cdr l))
      (else (cons (car l) (rember-f1 test? a (cdr l)))))))

\end{verbatim}

\item In the above version of \texttt{rember-f} we are passing a `test function' such as \texttt{eq?} and this \texttt{eq?} gets applied within the function \texttt{rember-f}.
\item When \texttt{=} passed we compare numbers, when \texttt{eq?} is passed we compare objects such as symbols or strings and when \texttt{equal?} is passed we compare structures like a list.
\end{itemize}

\subsubsection{Functions Returning a Function}
\label{sec:org740b5a7}

\begin{itemize}
\item So far we have seen functions returning lists and atoms.
\item We get to know in this section that functions can return functions too.
\item \texttt{(lambda (a l)...)} is a function which takes two arguments \texttt{a} and \texttt{l}.
\item Moses Schönfinkel was a mathematician who was the inventor of combinatory logic. He was the first person to show that functions that take two or more arguments could be reduced to
functions by taking only a single argument. Later the mathematician Haskell Curry after whom the programming language Haskell is named took this concept mainstream and it has been called
Currying ever since. Unfortunately Schönfinkel spent his last days in poverty. After he was gone his papers were burnt down by neighbors in Moscow for heating! There are only two papers by
him which remain. Everything else was lost. We do not know where those ideas could have led us to.
\item Using \texttt{define} we give the lambda function a name. For instance in the case below.
\begin{verbatim}
(define eq?-c
  (lambda (a)
    (lambda (x)
      (eq? x a))))

\end{verbatim}
\item In the function above if we pass something as the argument the function returns a function object. For instance in my case Dr Racket mentions that it is returning a procedure.
\begin{verbatim}
> (eq?-c 'salad)
#<procedure:...chemer-workbook.rkt:593:4>

\end{verbatim}
\item Without giving a name to this function we can still pass the two arguments to the function.
\begin{verbatim}
> (eq?-salad 'salad)
>(eq?-salad 'salad)
<#t
#t
> (eq?-salad 'tuna)
>(eq?-salad 'tuna)
<#f
#f
> ((eq?-c 'salad) 'salad)
#t
> ((eq?-c 'salad) 'tuna)
#f

\end{verbatim}
\item Now we will curry the \texttt{rember-f} function (it is actually only partially curried). Now this function returns another function after taking only argument.
\begin{verbatim}
    (define rember-f
      (lambda (test?)
        (lambda (a l)
          (cond
            ((null? l) (quote ()))
            ((test? a (car l)) (cdr l))
            (else (cons (car l)
                        ((rember-f test?) a (cdr l))))))))
> ((rember-f eq?) 'tuna '(shrimp salad and tuna salad))
'(shrimp salad and salad)
> ((rember-f eq?) 'eq? '(equal? eq? eqan? eqlist? eqpair?))
'(equal? eqan? eqlist? eqpair?)

\end{verbatim}
\end{itemize}

\subsubsection{Passing Anonymous Functions as Arguments}
\label{sec:orgf209803}

\begin{itemize}
\item The insert left or right functions can also be partially curried. One question asked is what is the difference between these two. Its only the order of \texttt{cons} in
the second test that is all.
\begin{verbatim}
(define insertL-f
  (lambda (test?)
    (lambda (new old l)
      (cond
        ((null? l) (quote ()))
        ((test? (car l) old)
         (cons new (cons old (cdr l))))
        (else (cons (car l)
                    ((insertL-f test?) new old (cdr l))))))))

(define insertR-f
  (lambda (test?)
    (lambda (new old l)
      (cond
        ((null? l) (quote ()))
        ((test? (car l) old)
         (cons old (cons new (cdr l))))
        (else (cons (car l)
                    ((insertR-f test?) new old (cdr l))))))))

\end{verbatim}
\item The difference in the two can written separately as helper functions and then we can call a generic \texttt{insert-g} with these helper functions to get \texttt{insertL-f} or
\texttt{insertR-f}.
\begin{verbatim}
(define seqL
  (lambda (new old l)
    (cons new (cons old l))))

(define seqR
  (lambda (new old l)
    (cons old (cons new l))))

\end{verbatim}

\item Time to write the left or write agnostic function which will take \texttt{seqL} or \texttt{seqR}. Notice we remove the \texttt{test?} this is so because are sort of removing a degree of freedom.
We are abstracting out the part that varies to make functions more general and in this case we are 'okay' with \texttt{eq?}.
\begin{verbatim}
(define insert-g
  (lambda (seq)
    (lambda (new old l)
      (cond
        ((null? l) (quote ()))
        ((eq? (car l) old)
         (seq new old (cdr l)))
        (else (cons (car l)
                    ((insert-g seq) new old (cdr l))))))))

\end{verbatim}
\item Now we can define the left and right functions by passing helper functions appropriately. But do we need to pass \texttt{seqL} and \texttt{seqR} and why not something generic as \texttt{seq}?
\begin{verbatim}
(define insertL (insert-g seqL))
(define insertR (insert-g seqR))

\end{verbatim}
\item Now comes the idea of passing anonymous or lambdas as the programming world calls it to functions. In Prof Touretzky's book also we have come across this.
\begin{verbatim}
    (define insertL-anon
      (insert-g
       (lambda (new old l)
        (cons new (cons old l)))))

> (insertL-anon 'x 'a '(a b c d))
'(x a b c d)

\end{verbatim}
\item Similarly for the \texttt{subst} substitute function we could create another helper function.
\begin{verbatim}
(define seqS
  (lambda (new old l)
    (cons new l)))

(define subst-def2
  (insert-g seqS))

(define subst-anon
  (insert-g
   (lambda (new old l)
     (cons new l))))

\end{verbatim}
\end{itemize}

\subsubsection{The Power of Functional Abstraction}
\label{sec:org7f39463}

\begin{itemize}
\item Now we come across a really smart abstraction. The book builds the \texttt{rember} function using \texttt{insert-g} and a new helper function \texttt{seqrem}. The catch is that the 'new' is simply ignored.
The authors use \texttt{\#f} in place of new and this is not for the lisp evaluator to look but we humans!
\begin{verbatim}
    (define rember-helper
      (lambda (a l)
        ((insert-g seqrem) #f a l)))

    (define seqrem
      (lambda (new old l)
        l))

> (rember-helper 'fries '(burger fries pizza chips))
'(burger pizza chips)

\end{verbatim}
\item What we have just seen is the power of abstraction!
\item Another example is the erstwhile \texttt{value} function where again we have common \texttt{cond} lines in the function definition.
\begin{verbatim}
(define value-helper
  (lambda (nexp)
    (cond
      ((atom? nexp) nexp)
      ((eq? (operator nexp) (quote +))
       (o+ (value-helper (1st-sub-exp nexp))
           (value-helper (2nd-sub-exp nexp))))
      ((eq? (operator nexp) (quote x))
       (o* (value-helper (1st-sub-exp nexp))
           (value-helper (2nd-sub-exp nexp))))
      (else
       (o^ (value-helper (1st-sub-exp nexp))
           (value-helper (2nd-sub-exp nexp)))))))

\end{verbatim}
\item Here we can abstract away the common portions of the function by writing a helper function \texttt{atom-to-function}.
\begin{verbatim}
    (define atom-to-function
      (lambda (x)
        (cond
          ((eq? x (quote +)) o+)
          ((eq? x (quote x)) o*)
          (else o^))))

> (atom-to-function '+)
#<procedure:o+>
> ((atom-to-function '+) 5 3)
8

\end{verbatim}

Note that the \texttt{1st-sub-exp} and \texttt{2nd-sub-exp} are just names and need to be given definitions for these functions of \texttt{value} and its variants to run. The code shown in the book is to only
illustrate abstraction and helper functions.

\item Here we should clarify some terms and reiterate them:
\begin{itemize}
\item Accessor Functions are also called Helper Functions. These functions help access some part or element in a list.
\item Meta Functions are those functions which operate on functions themselves. Meta Functions take in functions and return functions.
\item We can have a combination of accessor functions in a meta function.
\end{itemize}

\item This chapter is taking us the readers through this cycle essentially:
\begin{itemize}
\item Writing a `crude' or basic function which just gets the job done for instance the \texttt{insertL} function.
\item Then we go to a factored or parametrized version of the `crude' function now called `f' function such as \texttt{insertL-f}.
\item From the factored version we go to a general version or the `g' version such as \textasciitilde{}insert-g'.
\item And finally we will reach the evaluator example \texttt{value-helper} above.
\end{itemize}

\item We had written the \texttt{multirember} function earlier which was fairly easy.
\begin{verbatim}
(define multirember
  (lambda (a lat)
    (cond ((null? lat) (quote ()))
          ((eq? (car lat) a) (multirember a (cdr lat)))
          (else (cons (car lat) (multirember a (cdr lat)))))))

\end{verbatim}

\item Now the factorized version is below.
\begin{verbatim}
    (define multirember-f
      (lambda (test?)
        (lambda (a lat)
          (cond ((null? lat) (quote ()))
                ((test? a (car lat))
                 ((multirember-f test?) a (cdr lat)))
                (else (cons (car lat)
                            ((multirember-f test?) a (cdr lat))))))))

> ((multirember-f eq?) 'samosa '(pakora samosa chaat jalebi samosa chutney))
'(pakora chaat jalebi chutney)

\end{verbatim}

\item We can now make the test in \texttt{multirember-f} be only \texttt{eq?} by the following definition:
\begin{verbatim}
    (define multirember-eq?
      (multirember-f eq?))

> (multirember-eq? 'tuna '(tuna fish is good for health but not fried tuna fish))
'(fish is good for health but not fried fish)

\end{verbatim}

\item Next line of reasoning is that the \texttt{multirember-f} gos through the \texttt{lat} looking only for tuna and using \texttt{eq?} to test that. So we can probably merge this as one function.
So let us write a generic function which uses \texttt{eq?} to test if it is tuna or not.
\begin{verbatim}
    (define eq?-tuna
      (eq?-c (quote tuna)))

> (eq?-tuna 'fish)
#f
> (eq?-tuna 'tuna)
#t

\end{verbatim}

\item Now we can write a function \texttt{multiremberT} which takes \texttt{eq?-tuna} as an input for the test and comparison to tuna and a list of atoms as the second argument. This
makes our function compact and purposeful. Taking a step back \texttt{multiremberT} does the following:
\begin{itemize}
\item Takes two arguments: one is a function and another is a list. We could perhaps curry this further and have just one argument (perhaps).
\item The functional argument is a combination of another function \texttt{eq?-tuna} which in turn calls \texttt{eq?-c} ()itself is a curried function) with the symbol tuna.
\item The basic recursion is fairly simple. If we see \texttt{multiremberT} takes a function calls another function which in turn calls another function. These are layers of abstractions
for a higher order function.
\end{itemize}
Let us write the function now.
\begin{verbatim}
    (define multiremberT
      (lambda (test? lat)
        (cond ((null? lat) (quote ()))
              ((test? (car lat))
               (multiremberT test? (cdr lat)))
              (else (cons (car lat)
                          (multiremberT test? (cdr lat)))))))

> (multiremberT eq?-tuna '(shrimp salad tuna salad and tuna))
'(shrimp salad salad and)

\end{verbatim}
\end{itemize}

\subsubsection{Collector Functions or Continuations}
\label{sec:org7c1a579}

\begin{itemize}
\item This is the last commandment for the book and it gets fairly dense.
\item We write a function called \texttt{multirember\&co}. The book will now slowly step by step explain the definition of the function. But we will state it first and then work through it to
understand what it really is doing.
\begin{verbatim}
(define multirember&co
  (lambda (a lat col)
    (cond ((null? lat) (col (quote ()) (quote ())))
          ((eq? (car lat) a)
           (multirember&co a (cdr lat)
                           (lambda (newlat seen)
                             (col newlat
                                  (cons (car lat) seen)))))
          (else
           (multirember&co a (cdr lat)
                           (lambda (newlat seen)
                             (col (cons (car lat) newlat)
                                  seen)))))))

\end{verbatim}

\item Another function is defined which will be used as the continuation or collectors as we progress. It is called right now \texttt{a-friend}.
\begin{verbatim}
(define a-friend
  (lambda (x y)
    (null? y)))

\end{verbatim}
\end{itemize}

\subsubsection{Continuation Passing Style}
\label{sec:org9d19bd3}

\begin{itemize}
\item In this section we blow the lid off. Here we will learn a foundational concept for interpreters, compilers, lazy evaluation, backtracking etc.
\item Now let us get to work on \texttt{multirember\&co} function with the null list \texttt{()} as \texttt{lat}. We pass \texttt{a} as \texttt{'tuna}, \texttt{lat} as \texttt{()} and the \texttt{col} that is the collector as \texttt{a-friend}.
Since the \texttt{lat} is empty it hits the first line of \texttt{cond} which is \texttt{((null? lat) (col (quote ()) (quote ())))}. The collector takes the two \texttt{quote()} and since the second
one is an empty list it returns a \texttt{\#t}. Thus this comibination of arguments when passed to \texttt{multirember\&co} will return \texttt{\#t}.
\begin{verbatim}
(define multirember&co
  (lambda (a lat col)
    (cond ((null? lat) (col (quote ()) (quote ())))
          ((eq? (car lat) a)
           (multirember&co a (cdr lat)
                           (lambda (newlat seen)
                             (col newlat
                                  (cons (car lat) seen)))))
          (else
           (multirember&co a (cdr lat)
                           (lambda (newlat seen)
                             (col (cons (car lat) newlat)
                                  seen)))))))

(define a-friend
  (lambda (x y)
    (null? y)))

\end{verbatim}

\item The question with the input of \texttt{lat} as \texttt{(strawberries tuna and swordfish)} should not even be attempted right now. After this section the answer will come in an instant. The authors perhaps
should have simplified the whole section a little bit more.
\item When \texttt{lat} is \texttt{(tuna)} and the collector is \texttt{a-friend}, we hit the second \texttt{cond} test. The recursive call to \texttt{multirember\&co} is with \texttt{('tuna '() col1)}. Here \texttt{col1} is the lambda function given as:
\begin{verbatim}
(lambda (newlat seen) (col newlat (cons (car lat) seen)))

\end{verbatim}

But in \texttt{col1} the \texttt{col} refers to the original \texttt{a-friend}. The book calls this \texttt{col1} as \texttt{new-friend}.
\begin{verbatim}
(define new-friend
  (lambda (newlat seen)
    (a-friend newlat (cons (quote tuna) seen))))

\end{verbatim}

When we recur on \texttt{lat} as \texttt{()} then the the first \texttt{cond} gets hit. Here the \texttt{col} is called the \texttt{new-friend}. So we pass two blank lists to \texttt{new-friend}. This in turn calls \texttt{a-friend} with a blank list and
a \texttt{(tuna)}. This returns \texttt{\#f}. In plain english what this whole mechanism is doing is "Remove all \texttt{'tuna} from \texttt{(and tuna)}, and then ask: did we remove none? We did remove one, so the answer is \texttt{\#f}."
\item Now if we think of the first question where the lat is \texttt{(strawberries tuna and swordfish)} we know the answer will be \texttt{\#f} but let us wait for the next example where \texttt{lat} is \texttt{(and tuna)}.
\item Let us write down all the calls for \texttt{(and tuna)}.

\emph{First Call}

Arguments:

\texttt{a} = \texttt{'tuna}

\texttt{lat} = \texttt{'(and tuna)}

\texttt{col} = \texttt{a-friend}

\texttt{lat} is not null, and \texttt{(car lat)} is \texttt{'and}, which is not \texttt{a}, so we go to the \texttt{else} branch:

This collector is called \texttt{latest-friend} in the book.
\begin{verbatim}
(lambda (newlat seen) (a-friend (cons 'and newlat) seen))

\end{verbatim}

\emph{Second Call}

Arguments:

\texttt{a} = \texttt{'tuna}

\texttt{lat} = \texttt{'(tuna)}

\texttt{col} = \texttt{latest-friend}

\texttt{lat} is not null, and \texttt{(car lat)} is \texttt{'tuna},  so we go to the middle branch:

This collector is our already described \texttt{new-friend} earlier but the \texttt{col} is actually the \texttt{latest-friend}.
\begin{verbatim}
(lambda (newlat seen) (latest-friend newlat (cons 'tuna seen)))

\end{verbatim}

\emph{Third Call}

Arguments:

\texttt{a} = \texttt{'tuna}

\texttt{lat} = \texttt{'()}

\texttt{col} = \texttt{new-friend} from above where \texttt{col} is \texttt{latest-friend}

\texttt{lat} is null, we hit the first condition of the \texttt{cond}:

\begin{verbatim}
(new-friend '() '())

\end{verbatim}

\emph{Unwinding Collectors}

This is where we see the inte-relationships of the various collector functions.

\begin{verbatim}
(new-friend '() '())
(latest-friend '() (cons 'tuna '()))
(latest-friend '() '(tuna))
(a-friend '(and) '(tuna))
(null? '(tuna))
> #f

\end{verbatim}
We can see the book calls out the last step where they say the arguments to \texttt{a-friend} is \texttt{'(and)} and \texttt{'(tuna)} which is exactly what we got in out detailed flow above. What we notice is that
the atoms which are not collected are in one list and the atoms which are collected are in the other list.
\item If we change the collector function to say return the length of the list where we have not collected then we will get the count of the list where the \texttt{a} is not present. The book gives this collector
as an example.
\begin{verbatim}
(define last-friend
  (lambda (x y)
    (length x)))

\end{verbatim}
\end{itemize}

\subsection{Examples on Continuations}
\label{sec:org098cf77}

\subsubsection{Inserting and counting: \texttt{multiinsertLR\&co}}
\label{sec:orgfcbcc32}
\begin{itemize}
\item We revisit the functions \texttt{multiinsertL} and \texttt{multiinsertR} from chapter 3: Cons the magnificent.
\item We can combine the left and right functions as one below:
\begin{verbatim}
(define multiinsertLR
  (lambda (new oldL oldR lat)
    (cond
      ((null? lat) (quote ()))
      (eq? (car lat) oldL
           (cons new
                 (cons oldL
                       (multiinsertLR new oldL oldR (cdr lat)))))
      (eq? (car lat) oldR
           (cons oldR
                 (cons new
                       (multiinsertLR new oldL oldR (cdr lat)))))
      (else
       (cons (car lat)
             (multiinsertLR new oldL oldR (cdr lat)))))))

\end{verbatim}

\item Now we can write a \texttt{multiinsertLR\&co} which will have a collector function. The collector will work on the new list of atoms and on the number of
left and right insertions. The outline of the function looks something like this.
\begin{verbatim}
(define multiinsertLR&co
  (lambda (new oldL oldR lat col)
    (cond
      ((null? lat) (col (quote ()) 0 0))
      ((eq? (car lat) oldL)
       (multiinsertLR&co new oldL oldR (cdr lat)
                         (lambda (newlat L R)
                           ...)))
      ((eq? (car lat) oldR)
       (multiinsertLR&co new oldL oldR (cdr lat)
                         (lambda (newlat L R)
                           ...)))
      (else
       (multiinsertLR&co new oldL oldR (cdr lat)
                         (lambda (newlat L R)
                           ...))))))


\end{verbatim}
\item The base collector in the \texttt{(null? lat)} test returns an empty list thus we return \texttt{(quote ())} and since there are no occurrences of \texttt{oldL} or \texttt{oldR}
the count remains 0 for both these.
\item The book now asks us exactly what I mention above that what happens in the case we pass an empty list as the \texttt{lat}.
\item The \texttt{else} part of the \texttt{cond} gets triggered when \texttt{(car lat)} is neither equal to \texttt{oldL} or \texttt{oldR}. The collector in the \texttt{else} part will take this \texttt{newlat} which
is essentially produced by \texttt{multiinsertLR\&co} on \texttt{(cdr lat)}, \texttt{oldL}, and \texttt{oldR}. The second and third arguments are the left and right insertion counts.
\item This \texttt{else} collector will apply the collector function on a \texttt{cons} of \texttt{(car lat)} to \texttt{newlat} and that is \texttt{(cons (car lat) newlat)} and the other two arguments to collector
will be \texttt{L} and \texttt{R} because we need to keep a count of the insertions.
\item The two collector in the \texttt{cond} for \texttt{oldL} and \texttt{oldR} will essentially be an appropriate \texttt{cons} of \texttt{new} to \texttt{oldL} or \texttt{oldR}. In addition we will increment \texttt{oldL} or \texttt{oldR} appropriately.
So finally we get \texttt{multiinsertLR\&co} as below and also we write the collector function here.
\begin{verbatim}
    (define multiinsertLR&co
      (lambda (new oldL oldR lat col)
        (cond
          ((null? lat) (col (quote ()) 0 0))
          ((eq? (car lat) oldL)
           (multiinsertLR&co new oldL oldR (cdr lat)
                             (lambda (newlat L R)
                               (col (cons new
                                          (cons oldL newlat))
                                          (add1 L) R))))
          ((eq? (car lat) oldR)
           (multiinsertLR&co new oldL oldR (cdr lat)
                             (lambda (newlat L R)
                               (col (cons oldR
                                          (cons new newlat))
                                    L (add1 R)))))
          (else
           (multiinsertLR&co new oldL oldR (cdr lat)
                             (lambda (newlat L R)
                               (col (cons (car lat) newlat) L R)))))))

    (define col
      (lambda (newlat L R)
        (cons newlat (cons L (cons R (quote ()))))))

> (multiinsertLR&co 'salty 'fish 'chips
                    '(chips and fish or fish and chips) col)
'((chips salty and salty fish or salty fish and chips salty) 2 2)

\end{verbatim}
\end{itemize}

\subsubsection{Multiple Number Operations: \texttt{evens-only*\&co}}
\label{sec:org11389ee}
\begin{itemize}
\item We got back to the \texttt{*} functions in this example. \texttt{*} functions basically traverse entire nested lists.
\item Short term objective is to right a functions which removes all odd numbers from a nested list of numbers. First we can write a predicate which tests if a number is even or not.
\begin{verbatim}
(define even?
  (lambda (n)
    (cond
      ((= (modulo n 2) 0) #t)
      (else #f))))

(define evens-only*
  (lambda (l)
    (cond
      ((null? l) (quote ()))
      ((atom? (car l))
       (cond
         ((even? (car l))
          (cons (car l) (evens-only* (cdr l))))
         (else (evens-only* (cdr l)))))
      (else (cons (evens-only* (car l))
                  (evens-only* (cdr l)))))))

\end{verbatim}
\item Note that I have used a different way to test whether a number is even or not from that of in the book. We should also look at the \texttt{trace} of this \texttt{evens-only*} to refresh the stack flow of
such a function.
\begin{verbatim}
> (evens-only* '((9 1 2 8) 3 10 ((9 9) 7 6) 2))
>(evens-only* '((9 1 2 8) 3 10 ((9 9) 7 6) 2))
> (evens-only* '(9 1 2 8))
> (evens-only* '(1 2 8))
> (evens-only* '(2 8))
> >(evens-only* '(8))
> > (evens-only* '())
< < '()
< <'(8)
< '(2 8)
> (evens-only* '(3 10 ((9 9) 7 6) 2))
> (evens-only* '(10 ((9 9) 7 6) 2))
> >(evens-only* '(((9 9) 7 6) 2))
> > (evens-only* '((9 9) 7 6))
> > >(evens-only* '(9 9))
> > >(evens-only* '(9))
> > >(evens-only* '())
< < <'()
> > >(evens-only* '(7 6))
> > >(evens-only* '(6))
> > > (evens-only* '())
< < < '()
< < <'(6)
< < '(() 6)
> > (evens-only* '(2))
> > >(evens-only* '())
< < <'()
< < '(2)
< <'((() 6) 2)
< '(10 (() 6) 2)
<'((2 8) 10 (() 6) 2)
'((2 8) 10 (() 6) 2)

\end{verbatim}

\item We write the function \texttt{evens-only*\&co} which removes the odd numbers from a nested list, multiplies all the even numbers and sums all the odd numbers which had been removed and gives this list
as the answer.
\begin{verbatim}
    (define evens-only*&co
      (lambda (l col)
        (cond
          ((null? l) (col (quote ()) 1 0))
          ((atom? (car l))
           (cond
             ((even? (car l))
              (evens-only*&co (cdr l)
                              (lambda (newl p s)
                                (col (cons (car l) newl)
                                          (* (car l) p) s))))
             (else (evens-only*&co (cdr l)
                                   (lambda (newl p s)
                                     (col newl p
                                               (+ (car l) s)))))))
          (else (evens-only*&co
                 (car l) (lambda (al ap as)
                           (evens-only*&co
                            (cdr l) (lambda (dl dp ds)
                                      (col (cons al dl)
                                           (* ap dp)
                                           (+ as ds))))))))))

> (evens-only*&co '((9 1 2 8) 3 10 ((9 9) 7 6) 2) col)
'(((2 8) 10 (() 6) 2) 1920 38)

\end{verbatim}

\item The last collector function we write in this chapter is not coincidentally called \texttt{the-last-friend}.
\begin{verbatim}
(define the-last-friend
  (lambda (newl product sum)
    (cons sum (cons product newl))))

\end{verbatim}
When we pass this to \texttt{evens-only*\&co} we get:
\begin{verbatim}
> (evens-only*&co '((9 1 2 8) 3 10 ((9 9) 7 6) 2) the-last-friend)
'(38 1920 (2 8) 10 (() 6) 2)

\end{verbatim}
\end{itemize}

\textbf{Core Terms/Concepts Learnt}
\begin{itemize}
\item Higher Order Functions
\item Meta Functions
\item Functions taking other functions as arguments
\item Functions returning functions
\item Collectors or Continuations
\item Helper Functions
\item Continuation Passing Style
\end{itemize}


\newpage

\section{\ldots{} and Again, and Again, and Again, \ldots{}}
\label{sec:org15f75df}

The hardest chapter: Derive recursion without names using self-application. Build the conceptual machinery that leads to fixed point combinators and the Y combinator.

\bigskip

Key Takeaway:

\emph{Partial Functions vs Total Functions}

\bigskip

\emph{Deriving the Y Combinator}

\bigskip

\emph{Y Combinator}

\vspace{1em}

\subsection{Partial Functions}
\label{sec:org607ff12}
\begin{itemize}
\item With a series of examples we are led to the concept of partial functions. Initially the reader will be stumped to find that their elementary logic be defied but on reading what
the function \texttt{looking} and \texttt{keep-looking} do then things fall into place easily. In this \texttt{lat} which is the argument to \texttt{looking} the numbers determine where we eventually land up
after multiple recursions and at times we will not reach the desired destination conclusively hence the function will return \texttt{\#f} while at other times it could skip certain elements
in \texttt{lat} forever. When the recursion skips certain element(s) then it is said to be a partial function. This is a very crude definition from what we observe from the initial examples.
\item The functions can be written as following. Note the argument \texttt{sorn} stands for symbol or number.
\begin{verbatim}
(define looking
  (lambda (a lat)
    (keep-looking a (pick 1 lat) lat)))

(define keep-looking
  (lambda (a sorn lat)
    (cond ((number? sorn)
           (keep-looking a (pick sorn lat) lat))
          (else (eq? sorn a)))))

\end{verbatim}

\item The unusual thing about the function \texttt{keep-looking} is that it does not recur on a part of the list and the book calls it `unnatural' recursion.
\item So depending on how the \texttt{lat} argument to \texttt{keep-looking} is the result returned could be anything. Sometimes (as above) it would skip certain elements forever, at times the recursion
will never stop (when a tuple of numbers is provided as \texttt{lat}). Example of an endless loops can be \texttt{(7 2 4 7 5 6 3)} and \texttt{(7 1 2 caviar 5 6 3)}.
\item Now the book calls \texttt{keep-looking} a partial function.
\item An example of infinite recursion or as the book calls it the `most partial' function.
\begin{verbatim}
(define eternity
  (lambda (x)
    (eternity x)))

\end{verbatim}
\item Now we come to the function \texttt{shift}. This function takes a pair in which the first element is itself a pair. It then takes the second of the first pair and builds a new pair with this
second as the first and the second pair as the second element of the second new pair. Function definition ans examples below.
\begin{verbatim}
    (define shift
      (lambda (pair)
        (build (first (first pair))
               (build (second (first pair))
                      (second pair)))))
> (shift '((a b) c))
'(a (b c))
> (shift '((a b) (c d)))
'(a (b (c d)))

\end{verbatim}
\item The next function \texttt{align} is tricky. It takes an argument called \texttt{pora} which is a pair or an atom. It aims to normalize a nested pair into a right associated form where the left branch is always atomic.
It converts \texttt{pora} to a form like this \texttt{(atom.fully aligned tail)}.
\begin{verbatim}
(define align
  (lambda (pora)
    (cond ((atom? pora) pora)
          ((a-pair? (first pora))
           (align (shift pora)))
          (else (build (first pora)
                       (align (second pora)))))))

\end{verbatim}
\item We want to now count the number of elements in \texttt{pora}. This is done by the function \texttt{length*} (\texttt{*} because it will traverse the entire nested list).
\begin{verbatim}
(define length*
  (lambda (pora)
    (cond ((atom? pora) 1)
          (else
           (+ (length* (first pora))
              (length* (second pora)))))))


\end{verbatim}
\item The \texttt{length*} function gives equal weight to all atoms to the arguments of \texttt{pora} and does not consider the complexity of the structure of \texttt{pora}. To correct this we write
a new function called \texttt{weight*}.
\begin{verbatim}
(define weight*
  (lambda (pora)
    (cond ((atom? pora) 1)
          (else
           (+ (* (weight* (first pora)) 2)
              (weight* (second pora)))))))

\end{verbatim}
\item The example given is important and we can work it out by hand. We notice the weights of the arguments get simpler once aligned.

Before aligning:
\begin{verbatim}
((a b) c)

= first: (a b)
  second: c

  (weight* (a b)) = (+ (*1 2) 1) = 3
  (weight* c)     = 1

Total = 3*2 + 1 = 7

\end{verbatim}

After aligning:
\begin{verbatim}
(a (b c))

= first: a
  second: (b c)

  (weight* a)     = 1
  (weight* (b c)) = (+ (*1 2) 1) = 3

Total = 1*2 + 3 = 5

\end{verbatim}

\item \texttt{align} is not a partial function because it yields a value for every argument.
\item We write \texttt{shuffle} which is also a partial function. What this function does it make the first element of the \texttt{pora} an atom and pushes the complex parts to the second element. Why
it is partial is because if the argument is \texttt{((a b) (c d))} this function will go on till eternity.
\begin{verbatim}
    (define shuffle
      (lambda (pora)
        (cond
          ((atom? pora) pora)
          ((a-pair? (first pora))
           (shuffle (revpair pora)))
          (else (build (first pora)
                       (shuffle (second pora)))))))

> (shuffle '(a (b c)))
'(a (b c))
> (shuffle '((a b) (c)))
'((c) (a b))
> (shuffle '((a b) c))
'(c (a b))
> (shuffle '((a b) (c d)))
. . user break

\end{verbatim}
\end{itemize}

\subsection{Recursive nature of functions}
\label{sec:org9eb780b}

\begin{itemize}
\item Next is the famous Collatz Conjecture which is defined as the function \texttt{C} in the book. Collatz rule is simple where we start from any positive integer and do repeated procedure basis the rule:
if even divide by 2 and if odd then multiply by 3 and add 1. No matter what the sequence terminates in 1. This has not been proven yet rigorously in mathematics since 1937.
Paul Erdős said about the Collatz conjecture that \emph{Mathematics may not be ready for such problems}. Why the book shows this example is because the computation of \texttt{C} is not narrowing down to a number.
The values of interim \texttt{C} jump around. I have added a few examples.
\begin{verbatim}
    (define C
      (lambda (n)
        (cond
          ((one? n) 1)
          (else
           (cond
             ((even? n) (C (/ n 2)))
             (else (C (add1 (* 3 n)))))))))

> (C 2)
>(C 2)
>(C 1)
<1
1

> (C 3)
>(C 3)
>(C 10)
>(C 5)
>(C 16)
>(C 8)
>(C 4)
>(C 2)
>(C 1)
<1
1

> (C 11)
>(C 11)
>(C 34)
>(C 17)
>(C 52)
>(C 26)
>(C 13)
>(C 40)
>(C 20)
>(C 10)
>(C 5)
>(C 16)
>(C 8)
>(C 4)
>(C 2)
>(C 1)
<1
1
>

\end{verbatim}
\item The next is the Ackermann function. The book uses the common version of this called the Ackermann–Péter function. Ackermann function is a total function but is not primitive recursive.
This means a computer program cannot compute it always generally speaking. Let us write the function and give it few seed arguments.
\begin{verbatim}
    (define A
      (lambda (n m)
        (cond
          ((zero? n) (add1 m))
          ((zero? m) (A (sub1 n) 1))
          (else (A (sub1 n) (A n (sub1 m)))))))
> (A 1 1)
>(A 1 1)
> (A 1 0)
> (A 0 1)
< 2
>(A 0 2)
<3
3

> (A 2 1)
>(A 2 1)
> (A 2 0)
> (A 1 1)
> >(A 1 0)
> >(A 0 1)
< <2
> (A 0 2)
< 3
>(A 1 3)
> (A 1 2)
> >(A 1 1)
> > (A 1 0)
> > (A 0 1)
< < 2
> >(A 0 2)
< <3
> (A 0 3)
< 4
>(A 0 4)
<5
5

\end{verbatim}
Now if we pass the argument (4 3) my machine will go on endlessly probably till the end of time.
\end{itemize}

\subsection{Turing Halting Problem}
\label{sec:org775d5ca}

\begin{itemize}
\item The next endeavor is to write a function which will tell us if a function is a total or a partial function. The book is slowly leading us into the true definition of recursion and functions
in computer science. This is the Turing Halting Problem. Some functions can be described but not defined. No function in Scheme (or any programming language) can determine in general whether another function halts.
This is not possible in Mathematics. There is no general procedure that can always tell whether a computation will halt. This is the cornerstone of computability theory, limits of programming languages
limits of mathematics, Gödel incompleteness, and Turing machines.
\end{itemize}

\subsection{What is Recursion? What is a Function?}
\label{sec:orge73855e}

\begin{itemize}
\item \texttt{will-stop?} is a function to show the Turing Halting problem cannot be `defined' in our programming language or for that matter any programming language. This is the last leg of this chapter.
\item We revisit the function \texttt{length} which counts the number of S-expressions in a list. It was in the chapter `Number Games'.
\begin{verbatim}
(define length
  (lambda (lat)
    (cond ((null? lat) 0)
          (else (add1 (length (cdr lat)))))))


\end{verbatim}
\item The last line of \texttt{length} refers to itself so if we do not \texttt{define} \texttt{length} then how would we refer back to it in the recursive call?
\end{itemize}

\subsubsection{Closures and Lexical Scoping}
\label{sec:org7165019}
\begin{itemize}
\item The first time we have a \texttt{lambda} expression without defining it. Dr. Racket will see the \texttt{lambda} expression, evaluate it and then return a procedure value which is a closure. So the value
of a \texttt{lambda} expression is a procedure. Now what is a closure? A closure is a function in its lexical scoped environment. A closure is a pair of \texttt{(code environment)}. We can use an example here
to differentiate between lexical scoping and dynamic scoping.
\begin{verbatim}
(let ((x 5))
  (lambda (y) (+ x y)))

\end{verbatim}

In this the \texttt{lambda} expression remembers the value \texttt{x = 5} even after it has left the \texttt{let}.
In lexical scoping a variable’s meaning is determined by where it appears in the source code. In dynamic scoping a variable’s meaning is determined by which function called which function at runtime.
\begin{verbatim}
(define x 10)

(define (f)
  x)

(define (g)
  (let ((x 20))
    (f)))

\end{verbatim}
Under lexical scoping what does \texttt{(g)} see the value of \texttt{x}? \texttt{g} calls \texttt{f} and \texttt{f} in turn sees that \texttt{x = 10}. Thus it is checking the environment to get the value of \texttt{x}.
But under dynamic scoping \texttt{(g)} will check the value of \texttt{x} on the call stack. And the value of \texttt{x} on call stack has changed from 10 to 20. So in this case \texttt{x = 20}.
\end{itemize}

\subsubsection{The Y Combinator Derivation}
\label{sec:org1237bee}

\begin{itemize}
\item Back to the first \texttt{lambda} expression. Here it is.
\begin{verbatim}
    (lambda (l)
      (cond
        ((null? l) 0)
        (else (add1 (eternity (cdr l))))))

#<procedure:...chemer-workbook.rkt:907:0>

\end{verbatim}
\item If we call this for an empty list all is good we get \texttt{0} as return. But when we call it for any other list the \texttt{eternity} call will go on for eternity! It keeps calling it itself with \texttt{'()}.
\begin{verbatim}
#<procedure:...chemer-workbook.rkt:906:0>
#<procedure:...chemer-workbook.rkt:912:3>
> ((lambda (l)
  (cond
    ((null? l) 0)
    (else (add1 (eternity (cdr l)))))) '())
0
> ((lambda (l)
  (cond
    ((null? l) 0)
    (else (add1 (eternity (cdr l)))))) '(a))
. . user break

\end{verbatim}

\item We can call the \texttt{eternity} as \texttt{length-0} because it returns \texttt{0} for an empty list. Thus we can rewrite it as below. 
\begin{verbatim}
(lambda (l)
  (cond
    ((null? l) 0)
    (else (add1 (length-0 (cdr l))))))

\end{verbatim}
\item Now for \texttt{length-1} up to one we can nest the two lambdas. Since we cannot use \texttt{define} to put in the function we place the \texttt{lambda} object itself. In fact we can keep adding for measuring
length of longer lists.
\begin{verbatim}
(lambda (l)
  (cond
    ((null? l) 0)
    (else
     (add1
      ((lambda (l)
         (cond
           ((null? l) 0)
           (else (add1
                  (eternity (cdr l))))))
      (cdr l))))))


\end{verbatim}
The same nesting can be done for \texttt{length-2} showing an application on a 2 element list below.
\begin{verbatim}
> ((lambda (l)
  (cond
    ((null? l) 0)
    (else
     (add1
      ((lambda (l)
         (cond
           ((null? l) 0)
           (else (add1
                  ((lambda (l)
                     (cond
                       ((null? l) 0)
                       (else
                        (add1
                         (eternity
                          (cdr l))))))
                   (cdr l))))))
       (cdr l)))))) '(a b))
2

\end{verbatim}

\item For \texttt{length-2} we can add more nesting (as above). I would not pass the function for multiple examples. One thing to note is that the scope of the parameters is local and we see the term \texttt{length} being used across. I think
this is done deliberately by the authors to drive this point home.
\item The playful but insightful question to ask is `What is recursion?' now.
\item If we could go on and on and keep nesting \texttt{lambdas} up to infinity with \texttt{length-infinity} being the last one perhaps then we would have derived the function for \texttt{length}. But it is not possible
to write an infinite function. But we do see patterns emerging, repetitions. We can abstract out the common recurring patterns as another function which is the ninth commandment.
\begin{verbatim}
((lambda (f)
   (lambda (l)
     (cond
       ((null? l) 0)
       (else (add1 (f (cdr l)))))))
 ((lambda (g)
    (lambda (l)
      (cond
        ((null? l) 0)
        (else (add1 (g (cdr l)))))))
  eternity))


              #<procedure:...chemer-workbook.rkt:906:0>
              #<procedure:...chemer-workbook.rkt:912:3>
              #<procedure:...chemer-workbook.rkt:919:3>
              > (((lambda (f)
                 (lambda (l)
                   (cond
                     ((null? l) 0)
                     (else (add1 (f (cdr l)))))))
               ((lambda (g)
                  (lambda (l)
                    (cond
                      ((null? l) 0)
                      (else (add1 (g (cdr l)))))))
                eternity)) '())
              0
              > (((lambda (f)
                 (lambda (l)
                   (cond
                     ((null? l) 0)
                     (else (add1 (f (cdr l)))))))
               ((lambda (g)
                  (lambda (l)
                    (cond
                      ((null? l) 0)
                      (else (add1 (g (cdr l)))))))
                eternity)) '(a))
              1
              > (((lambda (f)
                 (lambda (l)
                   (cond
                     ((null? l) 0)
                     (else (add1 (f (cdr l)))))))
               ((lambda (g)
                  (lambda (l)
                    (cond
                      ((null? l) 0)
                      (else (add1 (g (cdr l)))))))
                eternity)) '(a b))
              . . user break

\end{verbatim}

\item For \texttt{length-2} the change is below.
\begin{verbatim}
    ((lambda (length)
       (lambda (l)
         (cond
           ((null? l) 0)
           (else (add1 (length (cdr l)))))))
     ((lambda (length)
        (lambda (l)
          (cond
            ((null? l) 0)
            (else (add1 (length (cdr l)))))))
      ((lambda (length)
         (lambda (l)
           (cond
             ((null? l) 0)
             (else (add1 (length (cdr l)))))))
       eternity)))

> (((lambda (length)
   (lambda (l)
     (cond
       ((null? l) 0)
       (else (add1 (length (cdr l)))))))
 ((lambda (length)
    (lambda (l)
      (cond
        ((null? l) 0)
        (else (add1 (length (cdr l)))))))
  ((lambda (length)
     (lambda (l)
       (cond
         ((null? l) 0)
         (else (add1 (length (cdr l)))))))
   eternity))) '(a b))
2

\end{verbatim}
\item We still have repetitions in our functions above. We can still abstract away and make functions.
\item The authors guide us to rename the function which takes \texttt{length} as an argument and returns a function that looks like length.
\item Now comes a syntactic trick. Assume that the function to generate or get length is called \texttt{F}:
\begin{verbatim}
(lambda (length)
   (lambda (l)
     (cond
       ((null? l) 0)
       (else (add1 (length (cdr l)))))))

\end{verbatim}
\item We have to pass \texttt{eternity} to it. So we have to something like \texttt{F eternity}. This is the structure. An outer \texttt{lambda} can take this \texttt{F} and apply that \texttt{F} to eternity. Let
us build a basic length of empty list as an example.
\begin{verbatim}
((lambda (mk-length)
   (mk-length eternity))
 (lambda (length)
   (lambda (l)
     (cond
       ((null? l) 0)
       (else (add1 (length (cdr l))))))))

\end{verbatim}
What we have done is have \texttt{((lambda (F) (F eternity)).....F)}. The outer \texttt{lambda} returns \texttt{F eternity} just like before! Why are we doing this? So that we can nest it.
\item Now if we want to go for \texttt{length-1} or \texttt{length-2} we just need to make the outer \texttt{lambda} pass more \texttt{mk-length}. For instance:
\begin{verbatim}
((lambda (mk-length)
   (mk-length
    (mk-length
     (mk-length
      (mk-length
       (mk-length eternity))))))
 (lambda (length)
   (lambda (l)
     (cond
       ((null? l) 0)
       (else (add1 (length (cdr l))))))))

\end{verbatim}
\item The next manipulation which the book does is to get a structure of this form.
\begin{verbatim}
((lambda (mk-length)
   (mk-length mk-length))
 (lambda (mk-length)
   (lambda (l)
     (cond
       ((null? l) 0)
       (else (add1
              ((mk-length eternity) (cdr l))))))))

\end{verbatim}
The outer \texttt{lambda} is there and an inner \texttt{lambda}. After applying the inner \texttt{lambda} to the outer one we essentially get inner being applied to inner. For testing \texttt{'()} we see that
it hits \texttt{null?} and actually does not go into recurrence.
\item Also note that parameter name in the function does not matter.
\item The example for \texttt{(apples)} yields 1. This is something on the lines of \texttt{(F (F '(apples)))} where \texttt{F} is a combination of the outer \texttt{lambda} and inner one.
\item We can keep passing \texttt{mk-length} to itself.
\begin{verbatim}
((lambda (mk-length)
   (mk-length mk-length))
 (lambda (mk-length)
   (lambda (l)
     (cond
       ((null? l) 0)
       (else (add1
              ((mk-length mk-length) (cdr l))))))))

\end{verbatim}
\item We extract \texttt{mk-length} call to itself but we get an infinite recursion actually.
\begin{verbatim}
    ((lambda (mk-length)
       (mk-length mk-length))
     (lambda (mk-length)
       ((lambda (length)
          (lambda (l)
            (cond
              ((null? l) 0)
              (else (add1 (length (cdr l)))))))
        (mk-length mk-length))))

#<procedure:...chemer-workbook.rkt:1027:3>
. Interactions disabled; out of memory

\end{verbatim}
The book shows that with next set of recursions as examples.
\item Actually \texttt{mk-length} now is not returning a function anymore (it is a list).
\item The book now manipulates it into another lambda function.
\begin{verbatim}
((lambda (mk-length)
   (mk-length mk-length))
 (lambda (mk-length)
   (lambda (l)
     (cond
       ((null? l) 0)
       (else (add1
              ((lambda (x)
                 ((mk-length mk-length) x))
               (cdr l))))))))


((lambda (mk-length)
   (mk-length mk-length))
 (lambda (mk-length)
   ((lambda (length)
      (lambda (l)
        (cond
          ((null? l) 0)
          (else (add1 (length (cdr l)))))))
    (lambda (x)
      ((mk-length mk-length) x)))))


\end{verbatim}
\item The next modification is to move the \texttt{(lambda (length))} out. Before we did the opposite by replacing a name with its value, now we extract the value and give it a name.
We actually get the Y combinator now but the book will separate out the \texttt{length} function later.
\begin{verbatim}
((lambda (le)
   ((lambda (mk-length)
      (mk-length mk-length))
    (lambda (mk-length)
      (le (lambda (x)
            ((mk-length mk-length) x))))))
 (lambda (length)
   (lambda (l)
     (cond
       ((null? l) 0)
       (else (add1 (length (cdr l))))))))


\end{verbatim}
\item Extracting out the \texttt{length} function and giving it the official nomenclature.
\begin{verbatim}
(define Y
  (lambda (le)
    ((lambda (f) (f f))
     (lambda (f)
       (le (lambda (x) ((f f) x)))))))

\end{verbatim}
\item \texttt{(Y Y)} will be infinite recursion. \texttt{Y} is called the Y Combinator, \texttt{le} is the little evaluator. This \texttt{(Y Y)} has no base case.
\item This is a very difficult chapter and the authors could have done a much better job in teaching this. Trying to be clever does not lead to clarity in this chapter at all.
The above were my raw notes, I am going to put diagrams and more simplification in terms of visuals to clarify this. The intent of the chapter should be clear after reading these notes
but if one were to derive the Y Combinator by themselves it will be a tough task.
\end{itemize}


\textbf{Core Terms/Concepts Learnt}
\begin{itemize}
\item Partial Functions
\item Total Functions
\item Combinators
\item Turing Halting Problem
\item Fixed Point Combinators
\item Collectors or Continuations
\item Y Combinator
\end{itemize}



\newpage

\section{What Is the Value of All of This?}
\label{sec:org0cea4b8}

Climax of the book which leads to getting ready to build an interpreter.

\bigskip

Key Takeaway:

\emph{Use all previous ideas to sketch an interpreter: environments, lookup, closures, and application.
Shows that evaluation itself is just another recursive function built from structural principles.}


\vspace{1em}

\subsection{Entries and Lookups}
\label{sec:orgb4449b2}

\begin{itemize}
\item An entry is defined as a pair of lists whose first list is a set and both the lists in the entry have equal length.
\item We seem to be defining a method to look for a particular element in the set get its position and then lookup in the second list the element in the same position.
\item Now we build a function to do exactly this by looking up the position of an input in the first set and then finding the element in the second list.
\begin{verbatim}
(define lookup-in-entry
  (lambda (name entry entry-f)
    (lookup-in-entry-help name
                          (first entry)
                          (second entry)
                          entry-f)))

(define lookup-in-entry-help
  (lambda (name names values entry-f)
    (cond
      ((null? names) (entry-f name))
      ((eq? (car names) name)
       (car values))
      (else (lookup-in-entry-help name
                                  (cdr names)
                                  (cdr values)
                                  entry-f)))))

\end{verbatim}

\item We have a helper function \texttt{lookup-in-entry-help}. The book always uses fallback functions so the code stays `pure lambda' - no errors, no special forms, no exceptions.
\item This is how the interpreter will find values defined in nested scopes. We are building an interpreter in this chapter perhaps.
\item We will stack a new entry on top of the existing table via \texttt{(define extend-table ...)}.
\item So now we have a list of entries inside a table. We can look for specific values and if the value is appearing multiple times the evaluation order makes sure to return the first instance
only.
\item The \texttt{lookup-in-table} function is written which is fairly simple. The note here is how the \texttt{cdr} portion of the table is being recursed into. The bottom \texttt{lambda} function does that.
\begin{verbatim}
(define lookup-in-table
  (lambda (name table table-f)
    (cond
      ((null? table) (table-f name))
      (else (lookup-in-entry name (car table)
                             (lambda (name)
                               (lookup-in-table name
                                                (cdr table)
                                                table-f)))))))

\end{verbatim}
\item Reiterating that \texttt{value} is the function that returns the natural value of expressions.
\begin{verbatim}
> (car (quote (a b c)))
'a

\end{verbatim}
\item Then we \texttt{cons} in a nested fashion. Fairly straightforward.
\begin{verbatim}
    (cons rep-a
          (cons rep-b
                (cons rep-c (quote ()))))

> (cons 'a
      (cons 'b
            (cons 'c (quote ()))))
'(a b c)

\end{verbatim}
\item The book is driving us to something similar we see in macros of Common Lisp. We are quoting \texttt{car} and \texttt{quote} and then that is getting used to build a Lisp object which can further be evaluated.
\begin{verbatim}
    (cons rep-car
          (cons (cons rep-quote
                      (cons
                       (cons rep-a
                             (cons rep-b
                                   (cons rep-c
                                         (quote ()))))
                       (quote ())))
          (quote ())))

> (cons 'car
      (cons (cons 'quote
                  (cons
                   (cons 'a
                         (cons 'b
                               (cons 'c
                                     (quote ()))))
                   (quote ())))
      (quote ())))
'(car '(a b c))

\end{verbatim}
\end{itemize}

\subsection{Values}
\label{sec:org39c1607}

\begin{itemize}
\item Next is a series of expressions we can test out in the REPL of Dr Racket.
\begin{verbatim}
> (car (quote (a b c)))
'a

> (car (quote (a b c)))
'a

> (quote (car (quote (a b c))))
'(car '(a b c))

> (value (add1 6))
7

> (value 6)
6

> (value (quote nothing))
'nothing

\end{verbatim}
\item Although the \texttt{value} function which we defined this chapter assumes that it can take arguments of other types. So readers should be careful here, they will get an error. The book should have been more explicit.
\begin{verbatim}
(value '((lambda (nothing)
   (cons nothing (quote ())))
 (quote
  (from nothing comes something))))

> ((from nothing comes something))
\end{verbatim}
\item Similarly the next expression also is simple. It gives \texttt{something}.
\begin{verbatim}
((lambda (nothing)
   (cond
     (nothing (quote something))
     (else (quote nothing))))
   #t)
\end{verbatim}
\end{itemize}

\subsection{Types, Value, and Meaning}
\label{sec:org886f198}

\begin{itemize}
\item The next set of questions just wants us to know what types are and how they are being defined in the current context. Listing them below. For folks from C language do not get confused here! Also this type system is specific to
the book and has little or nothing to do with Scheme or Dr Racket. Again the book in this chapter is cryptic and for new comers tough to decipher.
\begin{itemize}
\item Number (for example 42, 007) is a \texttt{*const}
\item Boolean \texttt{\#t} or \texttt{\#f} is a \texttt{*const}
\item Atoms are \texttt{*const}
\item \texttt{(value car)} gives the primitive but `car' will be treated as an atom and give a \texttt{*const}
\item \texttt{(quote nothing)} gives the type in this case as \texttt{*quote}
\item An atom that is not a primitive is treated as a variable thus is given the type \texttt{*identifier}
\item A function made using \texttt{lambda} is simply given a \texttt{*lambda} type
\item When a \texttt{lambda} expression is called it is given the type \texttt{*application}
\item The conditional \texttt{cond} is given \texttt{*cond} type
\end{itemize}
So if we notice we have 6 types in this chapter built for us.
\item Now the authors say that for a particular type an appropriate action has to be taken for us to get its value.
\item Now we aim to write the function \texttt{value} and this is actually the interpreter. A very rudimentary one.
\item I will work backwards unlike the book. \texttt{value} takes and argument and finds its \texttt{meaning} in a table. When it is found it looks for the action to take. A conditional decides whether we need to check if its an atom and then
do a \texttt{atom-to-action} and if it is anything else then we check in the function \texttt{list-to-action} for the application type. The functions are written below.
\begin{verbatim}
(define expression-to-action
  (lambda (e)
    (cond
      ((atom? e) (atom-to-action e))
      (else (list-to-action e)))))

(define atom-to-action
  (lambda (e)
    (cond
      ((number? e) *const)
      ((eq? #t) *const)
      ((eq? #f) *const)
      ((eq? e (quote cons)) *const)
      ((eq? e (quote car)) *const)
      ((eq? e (quote cdr)) *const)
      ((eq? e (quote null?)) *const)
      ((eq? e (quote eq?)) *const)
      ((eq? e (quote atom?)) *const)
      ((eq? e (quote zero?)) *const)
      ((eq? e (quote add1)) *const)
      ((eq? e (quote sub1)) *const)
      ((eq? e (quote number?)) *const)
      (else *identifier))))

(define list-to-action
  (lambda (e)
    (cond
      ((atom? (car e))
       (cond
         ((eq? (car e) (quote quote)) *quote)
         ((eq? (car e) (quote lambda)) *lambda)
         ((eq? (car e) (quote cond)) *cond)
         (else *application)))
      (else *application))))

(define value
  (lambda (e)
    (meaning e (quote ()))))

(define meaning
  (lambda (e table)
    ((expression-to-action e) e table)))

\end{verbatim}
\item A point to call out is that by the end of this chapter we truly would not have a full fledged interpreter but rather a working knowledge of the ingredients required to make one.
\item Some of the types get defined for the interpreter.
\begin{verbatim}
(define *const
  (lambda (e table)
    (cond
      ((number? e) e)
      ((eq? e #t) #t)
      ((eq? e #f) #f)
      (else (build (quote primitive) e)))))

(define *quote
  (lambda (e table)
    (text-of e)))

(define *identifier
  (lambda (e table)
    (lookup-in-table e table initial-value)))

(define initial-table
  (lambda (name)
    (car (qote ()))))

(define *lambda
  (lambda (e table)
    (build (quote non-primitive)
           (cons table (cdr e)))))


\end{verbatim}
\item Finally we see the explanation of what \texttt{cond} is. It is a series of tests with fall through as I noted it before. In Common Lisp we put a \texttt{t} and in Scheme we use \texttt{else}.
\begin{verbatim}
(define evcon
  (lambda (lines table)
    (cond
      ((else? (question-of (car lines)))
       (meaning (answer-of (car lines)) table))
      ((meaning (question-of (car lins)) table)
       (meaning (answer-of (car lines)) table))
      (else (evcon (cdr lines) table)))))

(define else?
  (lambda (x)
    (cond ((atom? x) (eq? x  (quote else)))
          (else #f))))


\end{verbatim}
Helper functions are also defined \texttt{question-of first} and \texttt{answer-of second}. In this definition every line of the \texttt{cond} should be true.
\item The book asks us to start having helper functions in place \texttt{table-of first}, \texttt{formals-of second}, and \texttt{body-of third}.
\item Finally
\begin{verbatim}
(define *cond
  (lambda (e table)
    (evcon (cond-lines-of e) table)))

\end{verbatim}
With a helper of \texttt{cond-lines-of cdr}.
\end{itemize}

\subsection{Evaluation and Application}
\label{sec:orgeb495f4}

\begin{itemize}
\item The working example is good to follow through. Here \texttt{coffee} evaluates to \texttt{\#t} and then \texttt{klatsch} gives 5 as the final answer.
\item An application is a list whose \texttt{car} is a function.
\item An application has to determine the meaning of all its arguments but that is not the case with special forms such as \texttt{cond} or logic ones such as \texttt{and} and \texttt{or}. This is
very important.
\item Now we evaluate a list via a function \texttt{evlis} which evaluates every argument. And then that is applied (we use helper functions again \texttt{function-of car} and \texttt{arguments-of cdr}).
\begin{verbatim}
(define evlis
  (lambda (args table)
    (cond
      ((null? args) (quote ()))
      (else (cons (meaning (car args) table)
                  (evlis (cdr args) table))))))
(define *application
  (lambda (e table)
    (apply
     (meaning (function-of e) table)
     (evlis (arguments-of e) table))))

\end{verbatim}
\item There are 2 types of functions - primitives and non primitives.
\begin{itemize}
\item A primitive is shown as \texttt{(primitive primitive-name)}
\item A non-primitive is shown as \texttt{(non-primitive (table formals body))}. \texttt{(table formals body)} is called a closure record.
\end{itemize}
\begin{verbatim}
(define primitive?
  (lambda (l)
    (eq? (first l) (quote primitive))))

(define non-primitive?
  (lambda (l)
    (eq? (first l) (quote non-primitive))))

\end{verbatim}
\item Now we write the \texttt{apply} function
\begin{verbatim}
(define apply
  (lambda (fun vals)
    (cond
      ((primitive? fun)
       ((apply-primitive (second fun) vals))
       ((non-primitive? fun)
        (apply-closure (second fun) vals))))))

\end{verbatim}
\item The helper function \texttt{apply-primitive} and \texttt{apply-closure} are written as follows.
\begin{verbatim}
(define apply-primitive
  (lambda (name vals)
    (cond
      ((eq? name (quote cons)) (cons (first vals) (second vals)))
      ((eq? name (quote car)) (car (first vals)))
      ((eq? name (quote cdr)) (cdr (first vals)))
      ((eq? name (quote null?)) (null? (first vals)))
      ((eq? name (quote eq?)) (eq? (first vals) (second vals)))
      ((eq? name (quote atom?)) (:atom? (first vals)))
      ((eq? name (quote zero?)) (zero? (first vals)))
      ((eq? name (quote add1)) (add1 (first vals)))
      ((eq? name (quote sub1)) (sub1 (first vals)))
      ((eq? name (quote number?)) (number? (first vals))))))

(define apply-closure
  (lambda (closure vals)
    (meaning (body-of closure)
             (extend-table
              (new-entry
               (formals-of closure)
               vals)
              (table-of clsoure)))))

\end{verbatim}
\item The book says that applying a non-primitive function is the same as finding the meaning of the closure's body with its table extended by an entry of the \texttt{(formals values)}.
\item In the final pages of the book the authors make us do some examples of the application of \texttt{meaning} on identifiers and constants.
\item We see the statement about applying a primitive function.
\item Then we see a statement about applying \texttt{cons} and which \texttt{cond} line we will hit. These last few examples seem like a starter for something major to come but would not be covered in this book.
\item Finally we come to \texttt{define} we skip it. We know that we truly do not needed because we have our Y Combinator.
\item The interpreter can run on the interpreter if we do the transformation with the Y combinator the book says.
\item Pretty sure The Seasoned Schemer will have much greater details in the book related to interpreters.
\item It is time for a banquet.
\end{itemize}


\textbf{Core Terms/Concepts Learnt}
\begin{itemize}
\item Entry
\item Types definition
\item Evaluation, Apply
\item Interpreter
\end{itemize}

\bigskip
\vspace{10em}

\begin{center}
\bigskip
\large { ~'(Bon Appétit)~}
\end{center}



\newpage

\section{Intermission}
\label{sec:orgaea1a9c}

\begin{itemize}
\item Books to read in my opinion from the list based on my personal knowledge
\begin{itemize}
\item The Seasoned Schemer
\item Naive Set Theory
\item How to Solve It
\item Introduction to Logic
\item Structure and Interpretation of Computer Programs
\item Alice's Adventure in Wonderland
\end{itemize}
\end{itemize}

\newpage

\thispagestyle{empty}
\begin{center}
\vspace*{0.3\textheight}
\large {\emph{``Now get ready for the next show''}}
\bigskip
\vfill
\end{center}
\clearpage
\end{document}
